# 11. 引用
>引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量，对引用的操作与对变量直接操作完全一样。  

## 使用注意事项 
- 引用必须初始化(引用必须指向所引用的对象)
    ```c++
    int a = 3;
    int& ra = a;
    int &b ;//错误，引用必须初始化
    const int &b = 10;//正确对字面值常量10的引用
    ```
- 引用不能为空
    ```c++
    int &b ;//错误，引用不能为空必须有所引用的对象
    ```
- 引用不能更换目标
    ```c++
    #include<iostream>
    using namespace std;
    int main(void){
        int a = 3;
        int b = 4;
        int& ra = a;
        // int& ra = b;//错误，多次初始化

        return 0;
    }
    ```


## C++ 把引用作为参数    
使用引用型参数有两个好处：  
1. 因为函数形参和实参是同一个对象，也就不存在对象复制，避免了对象的开销。  
2. 可以在修改形参的同时对实参的修改。  

用const 对引用加以修饰 也就是传常引用，可以避免函数对原来实参的意外修改。传常引用有两个优势:  
1. 因为不存在拷贝构造所以，可以提高c++程序的执行效率  
2. 避免对象切割问题。关于这点的详细讨论可以看effective c++ 。


```c++
#include <iostream>
using namespace std;
 
// 函数声明
void swap(int& x, int& y);
 
int main ()
{
   // 局部变量声明
   int a = 100;
   int b = 200;
 
   cout << "交换前，a 的值：" << a << endl;
   cout << "交换前，b 的值：" << b << endl;
 
   /* 调用函数来交换值 */
   swap(a, b);
 
   cout << "交换后，a 的值：" << a << endl;
   cout << "交换后，b 的值：" << b << endl;
 
   return 0;
}
 
// 函数定义
void swap(int& x, int& y)
{
   int temp;
   temp = x; /* 保存地址 x 的值 */
   x = y;    /* 把 y 赋值给 x */
   y = temp; /* 把 x 赋值给 y  */
  
   return;
}
```


## C++ 把引用作为返回值  
通过使用引用来替代指针，会使 C++ 程序更容易阅读和维护。C++ 函数可以返回一个引用，方式与返回一个指针类似。

当函数返回一个引用时，则返回一个指向返回值的隐式指针。这样，函数就可以放在赋值语句的左边。例如，请看下面这个简单的程序：
```c++
#include <iostream>
 
using namespace std;
 
double vals[] = {10.1, 12.6, 33.1, 24.1, 50.0};
 
double& setValues( int i )
{
  return vals[i];   // 返回第 i 个元素的引用
}
 
// 要调用上面定义函数的主函数
int main ()
{
 
   cout << "改变前的值" << endl;
   for ( int i = 0; i < 5; i++ )
   {
       cout << "vals[" << i << "] = ";
       cout << vals[i] << endl;
   }
 
   setValues(1) = 20.23; // 改变第 2 个元素
   setValues(3) = 70.8;  // 改变第 4 个元素
 
   cout << "改变后的值" << endl;
   for ( int i = 0; i < 5; i++ )
   {
       cout << "vals[" << i << "] = ";
       cout << vals[i] << endl;
   }
   return 0;
}
```

## c++左值引用和右值引用 [refer](https://liam.page/2016/12/11/rvalue-reference-in-Cpp/)   
>根据《C++ Primer》的说法，左值和右值可以这样区分：一个表达式是左值还是右值，取决于我们使用的是它的值还是它在内存中的位置（作为对象的身份）。也就是说一个表达式具体是左值还是右值，要根据实际在语句中的含义来确定。左值一般为对象，如变量等，右值为常值或者表达式。

**左值引用**是常见的引用。   
- 一般在提到「对象的引用」的时候，指得就是左值引用。在建立引用的时候，我们是「将内存空间绑定」，因此我们使用的是一个**对象在内存中的位置**，这是一个**左值**。因此，我们不能将一个右值绑定到左值引用上。
- 由于**常量左值引用**保证了我们不能通过引用改变对应内存空间的值，因此我们可以将右值绑定在常量引用上。
```c++
    //lvalue-reference
    int foo(42);
    int& bar = foo;  // OK: foo 在此是左值，将它的内存空间与 bar 绑定在一起
    int& baz = 42;   // Err: 42 是右值，不能将它绑定在左值引用上
    const int& qux = 42;  // OK: 42 是右值，但是编译器可以为它开辟一块内存空间，绑定在 qux 上
```
**右值引用**也是引用，但是它只能且必须绑定在右值上。由于右值引用只能绑定在右值上，而右值要么是字面常量，要么是临时对象，所以：  
- 右值引用的对象，是临时的，即将被销毁；
- 右值引用的对象，不会在其它地方使用。
```c++
    rvalue-reference
    int foo(42);
    int& bar = foo;        // OK: 将 foo 绑定在左值引用上
    int&& baz = foo;       // Err: foo 可以是左值，所以不能将它绑定在右值引用上
    int&& qux = 42;        // OK: 将右值 42 绑定在右值引用上
    int&& quux = foo * 1;  // OK: foo * 1 的结果是一个右值，将它绑定在右值引用上
    int& garply = foo++;   // Err: 后置自增运算符返回的是右值，不能将它绑定在左值引用上
    int&& waldo = foo--;   // OK: 后置自减运算符返回的是右值，将它绑定在右值引用上
```
**右值引用**可实现转移语义（Move Sementics）和精确传递（Perfect Forwarding），它的主要目的有两个方面：

- 消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。
- 能够更简洁明确地定义泛型函数。

## 引用折叠
c++11中，引用叠加有如下规则
```c++
Type&  &  -> Type&
Type&  && -> Type&
Type&& &  -> Type&
Type&& && -> Type&&
```