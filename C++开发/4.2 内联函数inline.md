# 4.2 内联函数inline
> c/c++程序在执行函数时，所用的时间主要分为**函数调用**和**执行函数体代码**。如果函数体代码比较多，需要较长的执行时间，那么函数调用机制占用的时间可以忽略；如果函数只有一两条语句，那么大部分的时间都会花费在函数调用机制上，这种时间开销就就不容忽视。  
为了解决一些<u>**频繁调用</u>的<u>小函数</u>大量消耗栈空间/栈内存**的问题，C++ 提供一种提高效率的方法，即在编译时将函数调用处用函数体替换，类似于C语言中的宏展开。特别的引入了 inline 修饰符，表示为**内联函数**。

- 使用示例：
    ```c++
    // c版本代码
    #include <stdio.h>
    //函数定义为inline即:内联函数
    inline char* dbtest(int a) {
        return (i % 2 > 0) ? "odd" : "even";
    } 
    
    int main()
    {
    int i = 0;
    for (i=1; i < 100; i++) {
        printf("i:%d    奇偶性:%s /n", i, dbtest(i));    
    }
    }
    ```
    上面的例子就是标准的内联函数的用法，使用 inline 修饰带来的好处我们表面看不出来，其实，在内部的工作就是在每个 for 循环的内部任何调用 dbtest(i) 的地方都换成了 (i%2>0)?"odd":"even"，这样就**避免了频繁调用函数对栈内存重复开辟所带来的消耗**。

## 定义 inline 函数
- 要在函数定义处添加 inline 关键字，在函数声明处添加 inline 关键字虽然没有错，但这种做法是无效的，编译器会忽略函数声明处的 inline 关键字。即“**inline是用于实现的关键字**”。
- 由于内联函数比较短小，我们通常的做法是**在函数声明时直接完成函数定义**。不推荐把内联函数的声明的定义分开。
- 最好将内联函数定义放在头文件中。

## 类中的成员函数与inline
- **定义在类中**的成员函数默认都是**内联**的;
- **定义在类外**的函数要**加上 inline**，否则就认为不是内联的。
    ```c++
    class A
    {
        public:void Foo(int x, int y) {  } // 自动地成为内联函数
    }

    //将成员函数的定义体放在类声明之中虽然能带来书写上的方便，但不是一种良好的编程风格，上例应该改成：

    // 头文件
    class A
    {
        public:void Foo(int x, int y);
    }
    // 定义文件
    inline void A::Foo(int x, int y){}
    ```

## inline仅是一个对编译器的建议
inline 函数仅仅是一个对编译器的建议，所以最后能否真正内联，看编译器的意思，它如果认为函数不复杂，能在调用点展开，就会真正内联，并不是说声明了内联就会内联，声明内联只是一个建议而已。

## 编译器对 inline 函数的处理步骤
1. 将 inline 函数体复制到 inline 函数调用点处；
2. 为所用 inline 函数中的局部变量分配内存空间；
3. 将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中；
4. 如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。

## 使用限制
inline 只适合函数体内代码简单的函数使用，不能包含复杂的结构控制语句例如 while、switch，并且内联函数本身不能是直接递归函数（即，自己内部还调用自己的函数）。

## 慎用 inline
内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。  

以下情况不宜使用内联：   
- 如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。 
- 如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。  
类的构造函数和析构函数容易让人误解成使用内联更有效。要当心构造函数和析构函数可能会隐藏一些行为，如"偷偷地"执行了基类或成员对象的构造函数和析构函数。

## 内联函数与宏（优缺点）
### inline优点
- 内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。
- 内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。预处理器在拷贝宏代码时常产生意想不到的边际效应，如：
    ```c
    #define MAX(a,b)  (a)>(b)?(a):(b)
    ```
    语句  
    ```c
    result=MAX(i,j)+2;
    ```
    将被处理器扩展为
    ```
    result=(a)>(b)?(a):(b)+2;
    ```

    因为"+"的优先级比运算符"?:"高，故上述语句不等价于
    ```
    result=((a)>(b)?(a):(b))+2;
    ```
    故常需要定义成
    ```c
    #define MAX(a,b)  ((a)>(b)?(a):(b))
    ```
- 在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的私有成员变量，宏定义则不能。
- 内联函数在运行时可调试，而宏定义不可以。
### inline缺点
- 代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。
- inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。
- 是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。

## 内联函数（inline）与虚函数（virtual）
- 虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。
- 内联是在编译器建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。
- inline virtual 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 Base::who()），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。
- 使用示例
    ```c++
    #include <iostream>  
    using namespace std;
    class Base
    {
    public:
        inline virtual void who()
        {
            cout << "I am Base\n";
        }
        virtual ~Base() {}
    };
    class Derived : public Base
    {
    public:
        inline void who()  // 不写inline时隐式内联
        {
            cout << "I am Derived\n";
        }
    };

    int main()
    {
        // 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。 
        Base b;
        b.who();

        // 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。  
        Base *ptr = new Derived();
        ptr->who();

        // 因为Base有虚析构函数（virtual ~Base() {}），所以 delete 时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。
        delete ptr;
        ptr = nullptr;

        system("pause");
        return 0;
    } 
    ```