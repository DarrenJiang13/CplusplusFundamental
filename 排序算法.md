# 排序算法

排序分类：

- 内部排序：在内存中进行的排序
  - 比较排序：包括插入/选择/交换/归并排序。
    - 插入排序:直接插入/希尔排序
    - 选择排序:直接选择/堆排序
    - 交换排序:冒泡/快速排序
    - 归并排序
  - 非比较排序：包括计数/基数/桶排序。  
- 外部排序：当数据量很大时无法全部拷贝到内存需要使用外存

| 排序算法 | 平均时间复杂度 | 最优时间复杂度 | 最差时间复杂度 | 空间复杂度 | 稳定性 |
| -------- | -------------- | -------------- | -------------- | ---------- | ------ |
| 插入排序 | O(n^2)         | O(n)           | O(n^2)         | O(1)       | 稳定 |
| 希尔排序 | O(n^1.3)       | O(n)           | O(n^2)         | O(1)       | 不稳定 |
| 选择排序 | O(n^2)         | O(n^2)         | O(n^2)         | O(1)       | 不稳定 |
| 堆排序 | O(n*log(n))    | O(n*log(n))    | O(n*log(n))    | O(1)       | 不稳定 |
| 冒泡排序 | O(n^2)         | O(n)           | O(n^2)         | O(1)       | 稳定 |
| 快速排序 | O(n*log(n))    | O(n*log(n))    | O(n^2)         | O(log(n))  | 不稳定 |
| 归并排序 | O(n*log(n))    | O(n*log(n))    | O(n*log(n))    | O(n)       | 稳定 |
|          |                |                |                |            |        |
| 计数排序 | O(n+k)         | O(n+k)         | O(n+k)         | O(n+k)     | 稳定 |
| 桶排序 | O(n+k)         | O(n)           | O(n^2)         | O(n+k)     | 稳定 |
| 基数排序 | O(k*n)         | O(k*n)         | O(k*n)         | O(n+k)     | 稳定 |

[refer](https://www.cnblogs.com/fnlingnzb-learner/p/9374732.html)  
[refer2](https://blog.csdn.net/zhangsy_csdn/article/details/91483600)  
方便记忆：
| 排序算法 | 平均时间复杂度 | 最优时间复杂度 | 最差时间复杂度 | 空间复杂度 | 稳定性 |
| -------- | -------------- | -------------- | -------------- | ---------- | ------ |
| 冒泡排序 | O(n^2)         | O(n)           | O(n^2)         | O(1)       | 稳定 |
| 选择排序 | O(n^2)         | O(n^2)         | O(n^2)         | O(1)       | 不稳定 |
| 插入排序 | O(n^2)         | O(n)           | O(n^2)         | O(1)       | 稳定 |
| 快速排序 | O(n*log(n))    | O(n*log(n))    | O(n^2)         | O(log(n))  | 不稳定 |
| 堆排序 | O(n*log(n))    | O(n*log(n))    | O(n*log(n))    | O(1)       | 不稳定 |
| 归并排序 | O(n*log(n))    | O(n*log(n))    | O(n*log(n))    | O(n)       | 稳定 |
| 希尔排序 | O(n^1.3)       | O(n)           | O(n^2)         | O(1)       | 不稳定 |
|          |                |                |                |            |        |
| 计数排序 | O(n+k)         | O(n+k)         | O(n+k)         | O(n+k)     | 稳定 |
| 桶排序 | O(n+k)         | O(n)           | O(n^2)         | O(n+k)     | 稳定 |
| 基数排序 | O(k*n)         | O(k*n)         | O(k*n)         | O(n+k)     | 稳定 |

## 1. 插入排序：直接插入

### 算法思想（从小到大）

1. 初始状态：
2. 找到起始值：
3. 第k次循环：
4. 终止循环：

### c++代码

```c++

}
```

### 算法分析

- 时间复杂度:  
- 空间复杂度：
- 稳定性： 

## 2. 插入排序：希尔排序

### 算法思想（从小到大）

1. 初始状态：
2. 找到起始值：
3. 第k次循环：
4. 终止循环：

### c++代码

```c++

}
```

### 算法分析

- 时间复杂度:  
- 空间复杂度：
- 稳定性： 

## 3. 选择排序：直接选择

> 初始时在序列中找到最小（大）元素，放到序列的起始位置作为已排序序列；然后，再从剩余未排序元素中继续寻找最小（大）元素，放到已排序序列的末尾。

### 算法思想（从小到大）

1. 初始状态：无序区为[1,2,3,4,...n]，有序区为空
2. 找到起始值：遍历数组，找到最小值所在的位置，与第1个元素交换，此时无序区为[2,3,4,...n]，有序区为[1]；
3. 第k次循环：从无序区中找到最小值，与无序区的第一个元素交换,交换后无序区第一个元素并入有序区，此时无序区变为[k+1,k+2,...n],有序区为[1，2，3，...k]
4. 终止循环：n-1趟选择之后，数组有序化

![Alt text](https://img-blog.csdnimg.cn/20190611232645313.gif)
### c++代码

```c++
// 从当前位置k之后的无序数组中选择最小的元素插入k+1
void selectSort(vector<int> &data){
    for(int i=0;i<data.size();i++){
        int tmp=i;
        // 1.search around the unsorted area and find the index of the minimum
        for(int j=i;j<data.size();j++){
            if(data[j]<data[tmp]){
                tmp=j;
            }
        }
        // 2.swap the minimum to the end of the sorted area
        swap(data[i],data[tmp]);
    }

    // 3. print the sorted array
    // for(int i=0;i<data.size();i++){
    //     cout<<data[i]<<" "<<endl;
    // }
    // cout<<endl;
}
```

### 算法分析

- 时间复杂度:  最优 O(n^2)， 平均 O(n^2)，最差 O(n^2)
- 空间复杂度：不占用额外内存空间。O(1)。
- 稳定性： 不稳定

## 4.选择排序：堆排序
### 算法思想（从小到大）

1. 初始状态：
2. 找到起始值：
3. 第k次循环：
4. 终止循环：

### c++代码

```c++

}
```

### 算法分析

- 时间复杂度:  
- 空间复杂度：
- 稳定性： 

## 5.交换排序：冒泡排序
### 算法思想（从小到大）

1. 初始状态：
2. 找到起始值：
3. 第k次循环：
4. 终止循环：

### c++代码

```c++

}
```

### 算法分析

- 时间复杂度:  
- 空间复杂度：
- 稳定性： 

## 6.交换排序：快速排序
### 算法思想（从小到大）

1. 初始状态：
2. 找到起始值：
3. 第k次循环：
4. 终止循环：

### c++代码

```c++

}
```

### 算法分析

- 时间复杂度:  
- 空间复杂度：
- 稳定性： 

## 7.归并排序
### 算法思想（从小到大）

1. 初始状态：
2. 找到起始值：
3. 第k次循环：
4. 终止循环：

### c++代码

```c++

}
```

### 算法分析

- 时间复杂度:  
- 空间复杂度：
- 稳定性： 

## 8.非比较排序：计数排序
### 算法思想（从小到大）

1. 初始状态：
2. 找到起始值：
3. 第k次循环：
4. 终止循环：

### c++代码

```c++

}
```

### 算法分析

- 时间复杂度:  
- 空间复杂度：
- 稳定性： 

## 9.非比较排序：基数排序
### 算法思想（从小到大）

1. 初始状态：
2. 找到起始值：
3. 第k次循环：
4. 终止循环：

### c++代码

```c++

}
```

### 算法分析

- 时间复杂度:  
- 空间复杂度：
- 稳定性： 

## 10.非比较排序：桶排序
### 算法思想（从小到大）

1. 初始状态：
2. 找到起始值：
3. 第k次循环：
4. 终止循环：

### c++代码

```c++

}
```

### 算法分析

- 时间复杂度:  
- 空间复杂度：
- 稳定性： 