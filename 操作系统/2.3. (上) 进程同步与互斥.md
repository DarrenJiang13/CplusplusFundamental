# 2.3 进程同步与互斥

## 2.3.1 进程同步，进程互斥
### **知识总览**
- 进程同步
- 进程互斥
### **进程同步**
> 由于并发必然导致异步性，但是实际应用中又必须按照一定的顺序，因此“进程同步”就是为了解决这种异步问题。
### **进程互斥**
- 临界资源：一个时间段内只允许一个进程使用的资源称为临界资源
    - 对临界资源的访问必须互斥地进行
- 进程互斥：当一个进程访问某临界资源的时候，另一个想要访问该临界资源的进程必须等待。
- 临界资源访问的逻辑四部分
    ```c++
    do{
        entry section;      //进入区：检查是否可进入临界区，若可以进入，设置“正在访问临界资源” 的标志
        critical section;   //临界区：访问临界资源的那段代码
        exit section;       //退出区：负责解除“正在访问临界资源”的标志
        remainder section;  //剩余区： 做其他处理

    } while(true)
    ```
    - 临界区是进程中负责访问资源的代码段
    - 进入区和退出区是负责实现互斥的代码段
- 实现进程互斥的原则
    - 空闲让进：临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区
    - 忙则等待：当已有进程进入临界区时，其他试图进入临界区的进程必须等待
    - 有限等待：对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）
    - 让权等待：当进程不能进入临界区时，应立即释放处理机，防止进程忙等待
### **知识回顾**
- 进程同步：
    - 并发性->异步性，有时候需要通过进程同步来解决这个问题
    - 有的进程之间需要配合工作，各进程的工作推进需要遵循一定的顺序
- 进程互斥：  
    对临界资源的访问需要互斥进行。即同一时间段只能允许一个进程访问该资源
    - 四个部分
        - 进入区:检查是否可进入临界区，若可进入，需要上锁
        - 临界区：访问临界资源的那段代码
        - 退出区：负责解锁
        - 剩余区：其余代码部分
    - 需要遵循的原则
        - 空闲让进：临界区空闲时，应允许一个进程访问
        - 忙则等待：临界区正在被访问时，其他试图访问的进程需要等待
        - 有限等待：要在有限时间内进入临界区，确保不会被饥饿
        - 让权等待：进不了临界区的进程，要释放处理机，防止忙等
    
## 2.3.2 进程互斥的软件实现方法
### **知识总览**
- 单标志法
- 双标志先检查
- 双标志后检查
- Peterson 算法
### **单标志法**
- 思想    
    两个进程在访问完临界区后会把使用临界区的权限交给另一个进程。每个进程进入临界区的权限只能被另一个进程赋予

- 原理  
    - turn初值为零，一开始只允许0号进程进入临界区
    - 临界区的访问顺序为“P0->P1->P0->P1->...”，必须为轮流访问
    ```c++
    int turn = 0;//turn 代表标志

    // P0 进程
    while(turn!=0);     //进入区
    critical section;   //临界区
    turn=1;             //退出区
    remainder section;  //剩余区

    //P1进程
    while(turn!=1);     //进入区
    critical section;   //临界区
    turn=0;             //退出区
    remainder section;  //剩余区
    ```
- 缺陷  
    因为必须为轮流访问，如果某个进程一直不访问临界区，则另一个进程也不被允许访问，违背“空闲让进”原则

### **双标志先检查**
- 思想    
    设置一个bool型数组，flag[]，来标记各个进程想进入临界区的意愿。

- 原理  
    ```c++
    bool flag[2];    //表示进入临界区意愿的数组
    flag[0]=false;
    flag[1]=false;   //刚开始两个进程都不想进入临界区
    
    //以下两个进程并发进行
    // P0 进程
    while(flag[1]);     //①进入区  P[1]若想进入，P0就一直循环等待
    flag[0]=true;       //②标记为P0想进入临界区   
    critical section;   //③临界区
    flag[0]=false;      //④退出区，P0不想进入临界区
    remainder section;  //⑤剩余区

    //P1进程
    while(flag[0]);     //⑥进入区,P[0]若想进入，P1就一直循环等待
    flag[1]=true;       //⑦标记为P1想进入临界区
    critical section;   //⑧临界区
    flag[1]=false;      //⑨退出区，P1不想进入临界区
    remainder section;  //⑩剩余区
    ```
- 缺陷  
    - 上述进程若按照162738..的顺序执行，P0和P1将会同时访问临界区
    - 违反“忙则等待”原则  
    - 原因：进入区的“检查”和“上锁”(flag置为true)两个操作不是一气呵成的，检查后上锁前可能发生进程切换。
    
### **双标志后检查**
- 思想    
    先检查法的改版。前一个算法问题先检查后上锁，后检查法为先上锁后检查。
- 原理  

    ```c++
    bool flag[2];    //表示进入临界区意愿的数组
    flag[0]=false;
    flag[1]=false;   //刚开始两个进程都不想进入临界区
    
    //以下两个进程并发进行
    // P0 进程
    flag[0]=true;       //①标记为P0想进入临界区   
    while(flag[1]);     //②进入区  P[1]若想进入，P0就一直循环等待
    critical section;   //③临界区
    flag[0]=false;      //④退出区，P0不想进入临界区
    remainder section;  //⑤剩余区

    //P1进程
    flag[1]=true;       //⑥标记为P1想进入临界区
    while(flag[0]);     //⑦进入区,P[0]若想进入，P1就一直循环等待
    critical section;   //⑧临界区
    flag[1]=false;      //⑨退出区，P1不想进入临界区
    remainder section;  //⑩剩余区
    ```
- 缺陷  
    - 若按162738...的顺序执行，P0和P1都无法进入临界区
    - 虽然解决了“忙则等待”的问题，但是违背了空闲让进和有限等待的原则，会导致临界资源无法分配而产生“饥饿”的现象。

### **Peterson 算法**
- 思想    
    双标志后检查法中，两个进程都争着想进入临界区，互不相让，最终谁都无法进入。 Peterson 让进程尝试孔融让梨，主动让对方先使用临界区

- 原理  
    - 主动争取
    - 主动谦让
    - 检查对方是不是想用
    ```c++
    bool flag[2];       //表示进入临界区意愿的数组
    flag[0]=false;
    flag[1]=false;      //刚开始两个进程都不想进入临界区
    int turn=0;         //turn 表示让哪个进程优先进入临界区
    
    //以下两个进程并发进行
    // P0 进程
    flag[0]=true;               //①标记为P0想进入临界区   
    turn=1;                     //②优先让给P1进程
    while(flag[1]&&turn==1);    //③进入区  P[1]若想进入，P0就一直循环等待
    critical section;           //④临界区
    flag[0]=false;              //⑤退出区，P0不想进入临界区
    remainder section;          

    //P1进程
    flag[1]=true;               //⑥标记为P1想进入临界区
    turn=0;                     //⑦优先让对方进入临界区
    while(flag[0]&&turn==0);    //⑧进入区,P[0]若想进入，P1就一直循环等待
    critical section;   //⑨临界区
    flag[1]=false;      //⑩退出区，P1不想进入临界区
    remainder section;     
    ```
- 优点  
    - 按123678...来执行，正常运行
    - 按1623...，正常运行
    - 遵循了 空闲让进，忙则等待，有限等待三个原则，但是仍未遵循 让权等待原则。

### **知识回顾**
- 单标志法
    - 在进入区只做“检查”，不“上锁”
    - 在退出区把临界区的使用权转交给另一个进程
    - 不遵循空闲让进原则
- 双标志先检查
    - 进入区： 先“检查”后“上锁”,退出区“解锁”
    - 主要问题：不遵循“忙则等待”原则
- 双标志后检查
    - 进入区： 先“上锁”后“检查”,退出区“解锁”
    - 主要问题：不遵循“空闲让进，有限等待”原则,可能导致饥饿
- Peterson 算法
    - 进入区： 主动争取->主动谦让->检查对方是否想进，己方是否谦让
    - 主要问题：不遵循“让权等待”原则,发生“忙等”

## 2.3.3 进程互斥的硬件实现方法
### **知识总览**
- 中断屏蔽方法
- TestAndSet(TS指令/TSL指令)
- Swap指令(XCHG指令)

### **中断屏蔽方法**
> 利用“开/关中断指令”实现，在某进程开始访问临界区到结束访问为止都不允许被中断，也就不能发生进程切换，因此也不可能发生两个同时访问临界区的情况。
- 优缺点
    - 优点  
        简单、高效
    - 缺点  
        - 不适用于多处理机。中断只在对应的处理机上操作。仍然可能出现另外一个处理机上的进程访问临界区的情况。
        - 开关中断属于特权指令。只适用于操作系统内核进程，不适用于用户进程。  

### **TestAndSet(TS指令/TSL指令)**
>TSL指令由硬件实现，执行的过程不可被中断，只能一气呵成。直到当前临界区的程序把lock设成false，才能继续进行。

- 原理
    ```c++
    // bool型共享变量lock代表当前临界区是否被加锁
    // true加锁，false未加锁
    bool TestAndSet(bool *lock){
        bool old;
        old=*lock;      //old 存放lock原来的值
        *lock=true;     //无论之前是否加锁，都将lock设为true
        return old;     //返回lock原来的值
    }

    //使用TSL指令实现互斥
    while(TestAndSet(&lock));//上锁并检查
    临界区代码段。。。
    lock=false;         //当前临界区的进程结束，解锁
    剩余区代码段
    ```
- 优缺点
    - 优点：实现简单，适用于多处理机
    - 缺点：不满足“让权等待”，暂时无法进入临界区的进程会占用CPU并循环执行TSL，从而忙等

### **Swap指令(XCHG指令)**
> 也是用硬件实现，执行过程不允许被中断。

- 原理
    ```c++
    // Swap 指令的作用是交换两个变量的值
    Swap(bool *a,bool *b){
        bool temp;
        temp=*a;
        *a=*b;
        *b=temp;
    }

    //使用Swap指令实现互斥
    //lock表示当前临界区是否被加锁
    bool old=true;
    while(old==true)
        Swap(&lock,&old)
    临界区代码段...
    lock=false;
    剩余区代码段...
    ```
- 优缺点
    - 优点： 实现简单； 适用于多处理机环境
    - 缺点： 不满足“让权等待” 原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致忙等。

### **知识回顾**
- 中断屏蔽方法
    - 使用“开/关中断”指令实现
    - 优点：简单高效
    - 缺点：不适用于多处理机；只适用于操作系统内核进程
- TestAndSet(TS指令/TSL指令)
    - old记录是否被上锁；再将lock设为true；检查临界区是否已被上锁；
    - 优点：实现简单，适用于多处理机
    - 缺点：不满足 让权等待
- Swap指令(XCHG指令)
    - old记录是否被上锁；再将lock设为true；检查临界区是否已被上锁；
    - 优点：实现简单，适用于多处理机
    - 缺点：不满足 让权等待

## 2.3.4 信号量机制
### **知识总览**
- 整型信号量
- 记录型信号量

### **信号量机制**
- 信号量其实就是一个变量（可以是一个**整数**，或者更复杂的**记录型变量**），可以用来表示系统中某种资源的数量
- 用户进程可以用操作系统提供的一对原语来对信号量进行操作
- 一对原语： wait(S)和signal(S), 常简称为P、V操作（来自荷兰语proberen和verhogen）

### **整型信号量**
> 用一个整数型的变量作为信号量，用来表示系统中某种资源的数量

- 三种操作：初始化，P操作，V操作
- 举例：
    ```c++
    int S=1;//初始化，代表当前系统中可用的打印机资源数

    void wait(int S){   //wait原语 相当于进入区
        while (S<=0);  //资源数不够，一直循环等待
        S=S-1;          //资源数够，占用一个资源
    }

    void signal(int S){ //signal原语，相当于退出区
        S=S+1;          //使用完资源后，退出区释放资源
    }


    //进程P0使用打印机
    ...
    wait(S);            //进入区：申请资源
    使用打印机资源...    //临界区：访问资源
    signal(S);          //退出区：释放资源
    ...
    ```
- 存在问题：不满足“让权等待”原则，会发生“忙等”

### **记录型信号量**
> 整型信号量的缺陷是存在“忙等”问题，因此人们提出了“记录型信号量” 用记录型数据结构表示信号量。
- 举例：
    ```c++
    // 记录型信号量的定义
    typedef struct{
        int value;          //剩余资源数
        struct process *L;  //等待队列
    }semaphore
    
    // 某进程需要使用资源时，使用wait原语进行申请
    void wait(semaphore S){
        S.value--;
        if(S.value<0){
            block(S.L); //若剩余资源不够，使用block原语使进程从运行态进入阻塞态
        }
    }

    // 某进程使用完资源后，使用signal原语进行释放
    void signal(semaphore S){
        S.value++;
        if(S.value<=0){  //释放资源后，还有别的进程在等待这种资源
            wakeup(S.L); //使用wakeup原语唤醒等待队列中的一个进程，该进程从阻塞态变为就绪态
        }
    }   
    ```
- 优点
    从wait函数中可以看出，该机制遵循了“让权等待”原则，资源数不够时，会自我阻塞。

### **知识回顾**
- 整型信号量
    - 用一个整数型的变量作为信号量，用来表示系统中某种资源的数量
    - 整型信号量和普通整型变量区别：对信号量只能执行初始化、P、V等操作
    - 问题： 不满足让权等待
- 记录型信号量
    - S.value代表某种资源数，S.L指向等待该资源的队列
    - P 操作，先S.value--,再block
    - V 操作，先S.value++,再wakeup原语
    - 注意：要能够推断什么条件下执行block或者wakeup
    - 可以用记录型信号量实现系统资源的“申请”和“释放”
    - 可以实现进程互斥和进程同步


## 2.3.5 用信号量机制实现进程互斥、同步、前驱关系
### **知识总览**
- 实现进程互斥
- 实现进程同步
- 实现进程的前驱关系

### **实现进程互斥**
1. 分析并发进程的关键活动，划定临界区
2. 设置互斥信号量mutex，初值为1
3. 在临界区之前执行P（mutex）
4. 在临界区之后执行V(mutex)
    ```c++
    //信号量机制实现互斥
    semaphore mutex=1； //初始化信号量

    P1(){
        ...
        P(mutex);   //使用信号量前需要加锁
        临界区代码段...
        V(mutex)；  //使用信号量后需要解锁
        ...
    }

    P2(){
        ...
        P(mutex);   //使用信号量前需要加锁
        临界区代码段...
        V(mutex)；  //使用信号量后需要解锁
        ...
    }
    ```
- 对不同的了临界资源需要设置不同的互斥信号量
- P、V操作必须成对出现。 缺少P(mutex)就不能保证临界资源的互斥访问，缺少V(mutex)会导致资源永不被释放，等待进程永不被唤醒

### **实现进程同步**
> 要让各并发进程按要求有序地推进（由于异步性）。
1. 分析什么地方需要实现“同步关系”，即必须保证“一前一后”执行的两个操作
2. 设置同步信号量S，初值为0
3. 在“前操作”之后执行V（mutex）
4. 在“后操作”之前执行P(mutex)
    ```c++
    //信号量机制实现tongbu
    semaphore S=0； //初始化信号量,初始值为0

    P1(){
        代码1；
        代码2；
        V(S);
        代码3；
    }

    P2(){
        P(S);       
        代码4；
        代码5；
        代码6；
    }
    ```
- 若先执行P1，则V(S)，S++,则S=1， 再执行P2，到P(S)，S--,S值变为0，P2进程不会执行block原语，继续往下执行代码4，顺序为先P1后P2
- 若先执行P2，再执行P1，则在P2的P(S)中会执行block原语，P2阻塞，等P1执行完V(S)之后，会执行wakeup原语，唤醒P2进程，P2继续执行代码4。顺序依然为先P1后P2

### **实现进程前驱关系**
> 每一对前驱关系都是一个进程同步问题
- 要为每一对前驱关系各设置一个同步变量
- 在前操作之后对相应的同步变量执行V操作
- 在后操作之前对相应的同步变量执行P操作

### **知识回顾**
- 实现进程互斥
    1. 分析问题，划定临界区
    2. 设置互斥信号量mutex，初值为1
    3. 在临界区之前执行P（mutex）
    4. 在临界区之后执行V(mutex)
- 实现进程同步
    1. 分析问题，找出什么地方需要实现“一前一后”的同步关系
    2. 设置同步信号量S，初值为0
    3. 在“前操作”之后执行V（mutex）
    4. 在“后操作”之前执行P(mutex)
- 实现进程前驱关系
    1. 分析问题，把每一个前驱关系都看成一个同步问题
    2. 为每一对前驱关系设置同步信号量S，初值为0
    3. 在“前操作”之后执行V（mutex）
    4. 在“后操作”之前执行P(mutex)