# 2.3 进程相关问题

## 2.3.6 生产者、消费者问题
> 系统里有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用。  

### **分析关系**
- 生产者，消费者共享一个**初始为空、大小为n**的缓冲区；
- 缓冲区没满，生产者才能放入产品(**同步关系，一前一后**)，否则必须等待；
- 缓冲区不空，消费者才能取出产品(**同步关系，一前一后**)，否则必须等待。
- 缓冲区是临界资源，各进程必须**互斥**访问。

### **代码实现**
```c++
semaphore mutex = 1 ;   //互斥信号量，实现对缓冲区的互斥访问
semaphore empty = n ;   //同步信号量，表示空闲缓冲区的数量
semaphore full = 0 ;    //同步信号量，表示产品的数量，也即非空缓冲区的数量

producer(){
    while(1){
        生产一个产品；
        P(empty);   //①
        P(mutex);   //②
        把产品放入缓冲区；
        V(mutex);
        V(full);
    }
}

consumer(){
    while(1){
        P(full);    //③
        P(mutex);   //④
        从缓冲区取出一个产品；
        V(mutex);
        V(empty);
        使用产品；
    }
}
```
- 问题：①和②，③和④能否被互换  
    1. 若互换，假设某一时刻缓冲区内已**放满**产品(empty=0,full=n)，则生产者进程先执行P(mutex)，再执行P(empty)。由于此时没有空闲缓冲区，故生产者被阻塞。切换回消费者进程，执行P(mutex)，由于此时mutex为零，即生产者还没释放锁，因此消费者也被阻塞。  
    此时生产者等待消费者释放空闲缓冲区，消费者又等待生产者释放临界区，互相等待，出现死锁。
    2. 假设某一时刻缓冲区内**没有**产品(full=0,empty=n)， consumer: P(mutex)->P(full)->producer:P(mutex)就会发生死锁。
    3. 综上，实现互斥的P操作一定要在实现同步的P操作之后。
- V进程不会导致进程阻塞，因此可以交换。
### **知识回顾**
1. 关系分析。找出各进程之间的同步、互斥关系；
2. 整理思路。根据各个进程的操作流程确定P、V的大致操作顺序；
3. 设置信号量（互斥为1，同步看对应资源数目）;

## 2.3.7 多生产者-多消费者问题
> 桌上有一盘子，每次只能放一个水果。  
爸爸只放苹果，妈妈只放橘子，儿子等吃橘子，女儿等吃苹果。  
盘子空时，爸爸或妈妈可向盘子中放水果，盘子有水果时，儿子或女儿可以取

### **分析关系**
- 互斥关系  
对缓冲区（盘子）的访问要互斥地进行
- 同步关系(一前一后)  
    1. 父亲放入苹果，女儿才能取
    2. 母亲放入橘子，儿子才能取
    3. 盘子为空时，父母才能放入水果

### **代码实现**
```c++
semaphore mutex = 1 ;   //互斥访问盘子（缓冲区）
semaphore apple = 0 ;   //盘中苹果数量
semaphore orange = 0 ;  //盘中橘子数量
semaphore plate = 1 ;   //盘中还能放多少水果

dad(){
    while(1){
        准备一个苹果；
        P(plate);
        P(mutex);
        把苹果放入盘子
        V(mutex);
        V(apple);
    }
}

mom(){
    while(1){
        准备一个橘子；
        P(plate);
        P(mutex);
        把橘子放入盘子
        V(mutex);
        V(orange);
    }
}

daughter(){
    while(1){
        P(apple);
        P(mutex);
        盘中取出苹果；
        V(mutex);
        V(plate);
        吃掉苹果；
    }
}

son(){
    while(1){
        P(orange);
        P(mutex);
        盘中取出橘子；
        V(mutex);
        V(plate);
        吃掉橘子；
    }
}
```

- 问题：可不可以不用互斥信号量?  
    此题中即使不设置mutex，也不会出现多个进程同时访问盘子的现象。 why？ 因为缓冲区大小为1。

## 2.3.8 吸烟者问题
> 假设一个系统有三个抽烟者进程和一个供应者进程。每个抽烟者不停地卷烟并抽掉它，但是要卷起并抽掉一支烟，抽烟者需要有三种材料：烟草、纸和胶水。三个抽烟者中，第一个拥有烟草、第二个拥有纸、第三个拥有胶水。供应者进程无限地提供三种材料，供应者每次将两种材料放桌子上，拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者进程一个信号告诉完成了，供应者就会放另外两种材料再桌上，这个过程一直重复（让三个抽烟者轮流地抽烟）

### **分析关系**
- 同步关系  
    1. 桌上有组合一  ->  第一个抽烟者取走东西
    2. 桌上有组合二  ->  第二个抽烟者取走东西
    3. 桌上有组合三  ->  第三个抽烟者取走东西
    4. 发出完成信号  ->  下一个组合放到桌上
### **代码实现**
```c++
semaphore offer1=0;     //桌上组合一的数量
semaphore offer2=0;     //桌上组合二的数量
semaphore offer3=0;     //桌上组合三的数量
semaphore finish=0;     //抽烟是否完成
int i=0;                //用于实现 三个抽烟者轮流抽烟

provider(){
    while(1){
        if(i==1){
            组合一放桌上；
            V(offer1);
        }
        else if(i==2){
            组合二放桌上；
            V(offer2);
        }
        else if(i==3){
            组合三放桌上；
            V(offer3);
        }   

        i=(i+1)%3;     
        P(finish);
    }
}

smoker1(){
    while(1){
        P(offer1);
        从桌上拿走组合一，卷烟抽掉；
        V(finish);
    }
}

smoker2(){
    while(1){
        P(offer2);
        从桌上拿走组合二，卷烟抽掉；
        V(finish);
    }
}

smoker3(){
    while(1){
        P(offer3);
        从桌上拿走组合三，卷烟抽掉；
        V(finish);
    }
}
```


## 2.3.9 读者、写者问题
> 有读者和写者两组并发进程，共享一个文件，当两个或两个以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误。因此要求：  
①允许多个读者可以同时对文件执行读操作；  
②只允许一个写者往文件中写信息；  
③任一写者在完成写操作之前不允许其他读者或写者工作；  
④写者执行写操作前，应让已有的读者和写者全部退出。

### **分析关系**
两类进程：读进程、写进程  
- 互斥关系：写-写，写-读，（读-读之间没有互斥关系）
    
### **代码实现**
```c++
semaphore rw=1;         //用于实现对共享文件的互斥访问
int count = 0;          //记录当前有几个读进程在访问文件
semaphore mutex = 1;    //用于保证对count变量的互斥访问

writer (){
    while(1){
        P(rw); //写之前“加锁”
        写文件… 
        V(rw); //写完了“解锁”
    }
}

reader(){
    while(1){
        P(mutex);          //各读进程互斥访问count
        if(count==0)P(rw); //第一个读进程负责“加锁”
        count++;            //访问文件的读进程数+1
        V(mutex); 

        读 文 件 … 

        P(mutex);           //各读进程互斥访问count
        count--;            //访问文件的读进程数-1
        if(count==0)V(rw);  //最后一个读进程负责“解锁”
        
        V(mutex);           

    }
}
- 此时读进程优先，若读进程一直在读，写进程要一直阻塞等待，可加入新的信号量实现写优先
```c++
semaphore rw=1;         //用于实现对共享文件的互斥访问
int count = 0;          //记录当前有几个读进程在访问文件
semaphore mutex = 1;    //用于保证对count变量的互斥访问
semaphore w = 1;        //用于保证“写优先”

writer (){
    while(1){
        P(w);
        P(rw); //写之前“加锁”
        写文件… 
        V(rw); //写完了“解锁”
        V(w);
    }
}

reader(){
    while(1){
        P(w);
        P(mutex);          //各读进程互斥访问count
        if(count==0)P(rw); //第一个读进程负责“加锁”
        count++;            //访问文件的读进程数+1
        V(mutex); 

        读 文 件 … 
        V(w);
        P(mutex);           //各读进程互斥访问count
        count--;            //访问文件的读进程数-1
        if(count==0)V(rw);  //最后一个读进程负责“解锁”
        
        V(mutex);           

    }
}
```

## 2.3.10 哲学家进餐问题
> 一张圆桌上坐着5名哲学家，每两个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭。哲学家们倾注毕生的精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿时， 才试图拿起左、右两根筷子（一根一根地拿起）。如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿起两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考。

### **分析关系**
- 互斥关系：5位哲学家与左右邻居对其中间筷子的访问是互斥关系
    
### **代码实现**
```c++
semaphore chopstick[5]={1,1,1,1,1};
Pi(){               //i号哲学家的进程
    while(1){
        P(chopstick[i]);        //拿左
        P(chopstick[(i+1)%5]);  //拿右
        吃 饭 … 
        V(chopstick[i]);        //放左
        V(chopstick[(i+1)%5]);  //放右
        思考…
    }
}
// 上述方案会发生死锁：每个哲学家都拿起了左手边的筷子
```

- 防止死锁发生  
    - 施加限制，比如最多允许四个哲学家同时进餐
    - 要求奇数号哲学家先拿左边，偶数号哲学家先拿右边。
    - 仅当一个哲学家左右两只筷子都可用时，才允许他抓起筷子
    ```c++
    semaphore chopstick[5]={1,1,1,1,1};
    semaphore mutex=1;  //互斥地取筷子
    Pi(){               //i号哲学家的进程
        while(1){
            P(mutex);
            P(chopstick[i]);        //拿左
            P(chopstick[(i+1)%5]);  //拿右
            V(mutex);
            吃 饭 … 
            V(chopstick[i]);        //放左
            V(chopstick[(i+1)%5]);  //放右
            思考…
        }
    }
    ```
## 2.3.11 管程
### **知识总览**
- 为什么引入管程
- 管程的定义和基本特征
- 拓展1：管程解决生产者消费者问题
- 拓展2：Java中类似于管程的机制

### **为什么引入管程**
> 信号量机制：编写程序困难、容易出错，引入一种高级同步机制————管程
### **管程的定义和基本特征**
- 组成
    - 管程有一个名字
    - 局部于管程的共享数据结构说明
    - 对局部于管程的共享数据设置初始值的语句
    - 对该数据结构进行操作的一组过程(过程就是函数)

- 基本特征
    - 局部于管程的数据只能被局部与管程的过程所访问
    - 一个进程只有通过调用管程内的过程才能进入管程访问共享数据
    - 每次只允许一个进程在管程内执行某个内部操作

### **拓展1：管程解决生产者消费者问题**
```c++
//pseudo code
monitor ProduceConsumer
    condition full, empty;  //条件变量实现同步
    int count=0;            //缓冲区中产品数
    void insert(Item item){ //把产品item放入缓冲区
        if(count==N)
            wait(full);
        count++;
        insert_item(item);
        if(count==1)
            signal(empty);
    }
    Item remove(){          //缓冲区中取出一个产品
        if(count==0)
            wait(empty);
        count--;
        if(count==N-1)
            signal(full);
        return remove_item();
    }
end monitor
// 生产者进程
produce(){
    while(1){}
        item =生产一个产品；
        ProducerConsumer.insert(item);
    }
}
//消费者进程
consumer(){
    while(1){
        item=ProducerConsumer.remove();
        消费产品item；
    }
}
```

- 如何解决互斥问题？  
当两个生产者进程并发执行，**编译器**负责各进程互斥地进入管程中的过程
- 如何解决同步问题  
两个消费者进程先执行，生产者进程后执行

### **拓展2：Java中类似于管程的机制**
用synchronized 定义函数

### **知识回顾**
- 为什么引入管程： 解决信号量机制编程麻烦、容易出错的问题
- 管程的定义和基本特征
    - 共享数据结构
    - 对数据结构初始化的语句
    - 访问该共享数据结构的过程
- 拓展1：管程解决生产者消费者问题
    - 各外部进程/线程只能通过管程提供的特定入口才能访问共享数据
    - 每次仅允许一个进程在管程内执行某个内部过程
    - 各进程必须互斥访问管程的特性是由编译器实现的
    - 可在管程中设置条件变量及等待/唤醒操作来解决同步问题
- 拓展2：Java中类似于管程的机制
