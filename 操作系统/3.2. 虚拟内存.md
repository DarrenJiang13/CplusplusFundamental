# 3.2. 虚拟内存

## 3.2.1 虚拟内存基本概念
### **知识总览**
- 传统存储管理方式的特征，缺点
- 局部性原理
    - 时间局部性
    - 空间局部性
    - 高速缓存技术
- 虚拟内存的定义与特征
- 如何实现虚拟内存技术

### **传统存储管理方式的特征，缺点**
特征：
- 一次性：作业必须一次性全部装入内存后才能开始运行
    - 造成问题
        - 作业很大时，不能全部装入，导致大作业无法运行
        - 大量作业要求运行时，内存无法容纳所有作业，只有少量作业能运行，导致多道程序并发度下降
- 驻留性：一旦作业被装入内存，就会一直驻留在内存中，直到作业运行结束

### **局部性原理**
- 时间局部性  
    - 如果执行了程序中的某条指令，那么不久后这条指令有可能再次执行；
    - 如果某个数据被访问过，不久之后该数据可能再次被访问
- 空间局部性  
    一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。（因为很多数据在内存中都是连续存放的）

### **虚拟内存的定义与特征**
> 基于局部性原理，在程序装入时，将程序中很快用到的部分装入内存，暂时用不到的装入外存。 程序执行时，访问的信息不在内存时，从外存调入；内存信息暂时用不到时，换出到外存。
- 特征
    - 多次性    
        无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存
    - 对换性    
        在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出
    - 虚拟性    
        从逻辑上扩充了内存的容量，使用户看到的内存容量远大于实际的容量

- 虚拟内存的最大容量和实际容量
    - 最大容量：计算机的地址结构(CPU寻址范围)决定
    - 实际容量：min(内存和外存容量之和，CPU寻址范围)

### **如何实现虚拟内存**
> 需要建立在离散分配（非连续）的内存管理方法基础之上。
- 非连续分配内存管理方法：
    - 基本分页存储管理
    - 基本分段存储管理
    - 基本段页式存储管理
- 虚拟内存的实现：   
    - 请求分页存储管理
    - 请求分段存储管理
    - 请求段页式存储管理

- 虚拟内存与传统非连续分配内存管理方法区别：
    - 程序执行时，访问的信息不在内存时，从外存调入；（请求调页）
    - 内存信息暂时用不到时，换出到外存。（页面置换/段置换）

### **知识回顾**
- 传统存储管理方式的特征，缺点
    - 一次性：作业必须一次性全部装入内存后才能开始运行
    - 驻留性：一旦作业被装入内存，就会一直驻留在内存中，直到作业运行结束
- 局部性原理
    - 时间局部性：现在访问的指令、数据不久后可能被再次访问
    - 空间局部性：现在访问的内存单元周围的内存空间，可能在不久之后会被访问
    - 高速缓存技术：使用频繁的数据放到更高速的存储器中
- 虚拟内存的定义与特征
    - 程序不需全部装入即可运行，运行时根据需要动态调入数据，若内存不够，还需换出一些数据
    - 特征
        - 多次性：无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存
        - 对换性：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出
        - 虚拟性：从逻辑上扩充了内存的容量，使用户看到的内存容量远大于实际的容量 
- 如何实现虚拟内存技术
    - 程序执行时，访问的信息不在内存时，从外存调入；（请求调页）
    - 内存信息暂时用不到时，换出到外存。（页面置换/段置换）
    - 实现
        - 请求分页存储管理
        - 请求分段存储管理
        - 请求段页式存储管理

## 3.2.2 请求分页管理方式
### **知识总览**
- 页表机制
- 缺页中断机构
- 地址变换机构

### **页表机制**
- 基本内存分页存储管理的页表：
    （页号） | 内存块号
- 请求分页存储管理的页表：
    （页号） | 内存块号 | 状态位 | 访问字段 | 修改位 | 外存地址
    - 状态位：是否已调入内存
    - 访问字段：最近被访问过几次，或记录上次被访问的时间
    - 修改位： 页面被调入内存后是否被修改过
    - 外存地址：页面在外存中的存放位置

### **缺页中断机构**
- 思想：
    - 请求分页系统中，每当要**访问的页面不在内存**时，便产生一个**缺页中断**，然后由操作系统的缺页中断处理程序处理中断。
    - 此时**缺页进程阻塞**，放入阻塞队列，调页完成后再将其唤醒，放回就绪队列

    - 如果内存中有空闲块，则**分配一个空闲块**，将所缺页面装入该块，并修改页表中相关的页表项。
    - 如果内存中没有空闲块，则由**页面置换算法**选择一个页面**淘汰**，如果该页面在内存期间**被修改过**，则要将其**写回外存**，未修改的不用写回外存。
- 中断的分类：
    - 内中断（内部异常，信号来自CPU内部）
        - 陷阱，陷入（trap）    
            有意为之的异常，如系统调用
        - 故障（fault）     
            由错误条件引起的，可能被故障处理程序修复，如缺页中断
        - 终止（abort） 
            不可恢复的致命错误造成的结果，终止处理程序不再将控制返回到引发终止的应用程序，如整数除以0；
    - 外中断（信号来自CPU外部）
        - I/O中断请求
        - 人工干预

### **地址变换机构**

### **知识回顾**
- 页表机制
    - 状态位：是否已调入内存
    - 访问字段：最近被访问过几次，或记录上次被访问的时间
    - 修改位： 页面被调入内存后是否被修改过，修改过的页面才需要在置换时候被写回外存
    - 外存地址：页面在外存中的存放位置   
- 缺页中断机构
    - 找到页表项后，检查页面是否已在内存，若没在内存，产生一个**缺页中断**。
    - 缺页中断处理中，需要将目标页面调入内存，有必要时还要换出界面
    - 缺页中断属于内中断，属于内中断中的故障，即可能被系统修复的异常
    - 一条指令在执行过程中可能产生多次缺页中断
- 地址变换机构
    - 找到页表项时需要检查页面是否在内存中
    - 若页面不在内存中，需要请求调页
    - 若内存空间不够，还需换出页面
    - 页面调入内存后，需要修改相应页表项


## 3.2.3 页面置换算法
> 页面的换入换出需要磁盘的I/O，会有较大开销，因此一个较好的页面置换算法应该追求更少的缺页率。
### **知识总览**
- 最佳置换算法（OPT）
- 先进先出置换算法（FIFO）
- 最近最久未使用置换算法（LRU）
- 时钟置换算法（CLOCK）
- 改进型的时钟置换算法

### **最佳置换算法（OPT）**
> 每次选择淘汰的页面将是以后永不使用，或者在最长时间内不被访问的页面，这样可以保证最低的缺页率

- 缺点：无法实现。 因为需要预测接下来访问的是哪个页面。
### **先进先出置换算法（FIFO）**
> 每次选择淘汰的页面，是最早进入内存的页面
- 实现方法：    
    把调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时选择队头页面即可。 队列的最大长度取决于系统为内存分配了多少个内存块
- 缺点：
    - 为进程分配的物理块数增大时，缺页次数不减反增 （belady异常）
    - 与实际运行规律不适应，先进入页面也有可能最经常被访问，算法性能差。
### **最近最久未使用置换算法（LRU）**
> 每次淘汰的页面时最近最久未使用的页面
- 实现方法：    
每个页面对应的页表项中，用访问字段记录该页面**自上次被访问以来所经历的时间t**。 当需要淘汰一个页面时选择现有页面中t值最大的，即最近最久未使用的页面。

- 缺点：    
    实现需要专门的硬件支持，虽然算法性能好，但是实现困难，开销大

### **时钟置换算法（CLOCK）**
> 一种性能和开销较为均衡的算法，或最近未用算法（NRU）

- 实现方法：    
    - 为每个页面设置为一个访问位（1：最近访问过；2：最近没访问过），再将内存中的页面都通过链接指针链接成一个循环队列。
    - 需要淘汰时，检查该页访问位，如果是1，将其置为0，如果是0，选择将该页换出。
- 缺点：
    如果被淘汰的页面没有被修改过，就不需要执行I/O操作写回外存。只有被淘汰的页面被修改过时，才需要写回外存
### **改进型的时钟置换算法**
> 操作系统在执行时钟置换算法时，除了考虑一个页面最近有没有被访问过之外，还应考虑最近有没有被修改过。在其他条件都相同时，应优先淘汰没有修改过的页面，避免I/O操作。

- 实现方法：    
    将所有可能被置换的页面排成一个循环队列，用（访问位，修改位）的形式表示各页面状态    
    1. 第一轮：从当前位置开始扫描到第一个（0，0）的帧用于替换，本轮扫描不修改任何标志位(最近没访问，且没修改过)
    2. 第二轮：若第一轮失败，则重新扫描，查找第一个（0，1）的帧用于替换。本轮把所有扫描过的访问位设为0(最近没访问，但修改过)
    3. 第三轮：若第二轮扫描失败，则重新扫描，查找第一个（0，0）的帧用于替换。本轮扫描不修改任何标志位(最近访问过，但没修改过)
    4. 若第三轮扫描失败，则重新扫描，查找第一个（0，1）的帧用于替换。(最近访问过，且修改过)
    5. 由于第二轮已将所有帧的访问位置为0，因此最终一定有一个帧被选中，因此改进型CLOCK置换算法选择一个淘汰页面最多会进行四轮扫描。

### **知识回顾**
|             | 算法规则                                                                                                                             | 优缺点                                        |
| ----------- | ---------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------ |
| OPT         | 优先淘汰最长时间内不会被访问的页面                                                                                      | 缺页率最小，性能最好，但无法实现 |
| FIFO        | 优先淘汰最先进入内存的页面                                                                                                  | 实现简单，但是性能很差，可能出现Belady异常 |
| LRU         | 优先淘汰最近最久没访问的页面                                                                                               | 性能很好；但需要硬件支持，算法开销大 |
| CLOCK(NRU)  | 循环扫描各页面。第一轮讨论访问位=0的，并将扫面描过的页面访问位改为1.若第一轮没选中，则进行第二轮扫描 | 实现简单，算法开销小，但是未考虑算法是否被修改过 |
| 改进型CLOCK | 若用（访问位，修改位）的形式表述，则第一轮：淘汰（0，0）；第二轮：淘汰（0，1），扫描过的置为0；第三轮：淘汰（0，0）;第四轮：淘汰（0，1） | 算法开销较小，性能也不错             |

## 3.2.4 页面分配策略
### **知识总览**
- 驻留集
- 页面分配，置换策略
    - 固定分配局部置换
    - 可变分配全局置换
    - 可变分配局部置换
- 调入页面的时机
- 从何处调页
- 抖动（颠簸）现象
- 工作集

### **页面分配，置换策略**
- 驻留集： 请求分页存储管理中给进程分配的物理块的集合
    - 驻留集太小：缺页频繁，大量时间处理缺页，用于进程推进时间很少
    - 驻留集太大：导致多道程序并发度下降，程序利用率减少

- 固定分配与可变分配
    - 固定分配：驻留集大小不变
    - 可变分配：进程运行过程中，驻留集大小可变

- 局部置换与全局置换
    - 局部置换：发生缺页时，只能选进程自己的物理块进行置换
    - 全局置换：可以将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换到外存，再分配给缺页内存

- 固定分配局部置换  
    - 实现：
        - 系统为每一个进程分配一定数量的物理块，在整个运行期间都不改变。（固定分配）
        - 若进程在运行中发生缺页，则只能从该进程在**内存中的页面中**选出一页换出，然后再调入需要的页面（局部置换）
    - 缺点：    
        很难在刚开始就确定为每个进程分配多少个物理块才合理

- 可变分配全局置换  
    - 实现：
        - 系统为每一个进程分配一定数量的物理块，操作系统会保持一个空闲物理块队列（可变分配）
        - 某进程发生缺页时，从空闲物理块中取出一块分配给该进程；若已无空闲物理块，则可选择一个**未锁定**的页面换出外存，再将物理块分配给缺页的进程。（全局置换）
        - 只要某进程发生缺页，就将获得新的物理块
        - 空闲物理块用完时，系统选择一个未锁定的页面调出，
    - 缺点：    
        被调出页面可能属于系统任何一个进程，所以该进程拥有的物理块会减少，缺页率会增加

- 可变分配局部置换  
    - 实现：
        - 系统为每一个进程分配一定数量的物理块，操作系统会保持一个空闲物理块队列
        - 某进程发生缺页时，从进程自己的物理块中取出一块进行换出外存；（局部置换）
        - 如果进程在运行中频繁的缺页，系统会为该进程多分配几个物理块，直至该进程缺页率适当；反之，则可适当减少分配给其的物理块（可变分配）
        
### **何时调入页面**
- 预调页策略：  
    > **进程运行前**预测不久之后可能访问到的页面，将他们预先调入内存。主要用于进程的首次调入，由程序员指出应该先调入哪些部分
- 请求调页策略：    
    > 进程在**运行期间**发现缺页时才将所缺页面调入内存。但由于每次只能调入一页，每次调页都要I/O操作，因此I/O开销较大。

### **何处调入页面**
- 系统拥有足够的对换区空间：    
    内存的调入调出都在内存与对换区之间进行
- 系统缺少足够的对换区空间：    
    - 不会被修改的数据：直接从文件区调入，因为不会被修改，所以换出时不必写回磁盘
    - 可能被修改的数据：换出时需写回磁盘对换区，下次需要再从对换区调入
- UNIX方式：
    - 运行之前进程有关的数据都在文件区，未使用过的页面，都可从文件区调入
    - 若被使用过的页面需要换出，则写回对换区，下次需要时从对换区调入

### **抖动/颠簸现象**
> 刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存。  
主要原因：进程频繁访问的页面数目高于可用的物理块数

- 为了解决这个问题提出了工作集的概念

### **工作集**
- 驻留集：分页存储管理中给进程分配的内存块的集合
- 工作集：进程在某段时间间隔内，进程实际访问页面的集合。驻留集一般不能小于工作集大小。

### **知识回顾**
- 驻留集： 请求分页存储管理中给进程分配的物理块的集合
- 页面分配，置换策略
    - 固定分配与可变分配：驻留集大小是否可变
    - 局部置换与全局置换：发生缺页时，是否选进程自己的物理块进行置换
    - 固定分配局部置换：进程运行前就分配一定数量块，缺页时只能换出进程自己的一页
    - 可变分配全局置换：只要缺页就分配新物理块，可能来自空闲物理块或者换出别的进程页面
    - 可变分配局部置换：频繁换页的进程多分配一些物理块，缺页率很低的进程，回收一些物理块
- 调入页面的时机
    - 预调页策略：进程运行前预先分配一定页数
    - 请求调页策略：进程运行时，发现缺页再调页
- 从何处调页
    - 对换区：采用连续存储方式，速度更快； 文件区-采用离散存储方式，速度更慢
    - 对换区足够大：    
        内存的调入调出都在内存与对换区之间进行
    - 对换区不够大：    
       不会被修改的数据：直接从文件区调入；可能被修改的数据：换出时需写回磁盘对换区，下次需要再从对换区调入
    - UNIX方式：    
        第一次使用使用过的页面，都可从文件区调入；若页面需要换出，则写回对换区，下次需要时从对换区调入
- 抖动（颠簸）现象  
    页面频繁换入换出的现象。主要原因是分配给进程的物理块不够
- 工作集    
    进程在某段时间间隔内，进程实际访问页面的集合。驻留集一般不能小于工作集大小。