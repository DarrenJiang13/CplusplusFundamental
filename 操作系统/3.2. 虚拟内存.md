# 3.2. 虚拟内存

## 3.2.1 虚拟内存基本概念
### **知识总览**
- 传统存储管理方式的特征，缺点
- 局部性原理
    - 时间局部性
    - 空间局部性
    - 高速缓存技术
- 虚拟内存的定义与特征
- 如何实现虚拟内存技术

### **传统存储管理方式的特征，缺点**
特征：
- 一次性：作业必须一次性全部装入内存后才能开始运行
    - 造成问题
        - 作业很大时，不能全部装入，导致大作业无法运行
        - 大量作业要求运行时，内存无法容纳所有作业，只有少量作业能运行，导致多道程序并发度下降
- 驻留性：一旦作业被装入内存，就会一直驻留在内存中，直到作业运行结束

### **局部性原理**
- 时间局部性  
    - 如果执行了程序中的某条指令，那么不久后这条指令有可能再次执行；
    - 如果某个数据被访问过，不久之后该数据可能再次被访问
- 空间局部性  
    一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。（因为很多数据在内存中都是连续存放的）

### **虚拟内存的定义与特征**
> 基于局部性原理，在程序装入时，将程序中很快用到的部分装入内存，暂时用不到的装入外存。 程序执行时，访问的信息不在内存时，从外存调入；内存信息暂时用不到时，换出到外存。
- 特征
    - 多次性    
        无需再作业运行时一次性全部装入内存，而是允许被分成多次调入内存
    - 对换性    
        在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出
    - 虚拟性    
        从逻辑上扩充了内存的容量，使用户看到的内存容量远大于实际的容量

- 虚拟内存的最大容量和实际容量
    - 最大容量：计算机的地址结构(CPU寻址范围)决定
    - 实际容量：min(内存和外存容量之和，CPU寻址范围)

### **如何实现虚拟内存**
> 需要建立在离散分配（非连续）的内存管理方法基础之上。
- 非连续分配内存管理方法：
    - 基本分页存储管理
    - 基本分段存储管理
    - 基本段页式存储管理
- 虚拟内存的实现：   
    - 请求分页存储管理
    - 请求分段存储管理
    - 请求段页式存储管理

- 虚拟内存与传统非连续分配内存管理方法区别：
    - 程序执行时，访问的信息不在内存时，从外存调入；（请求调页）
    - 内存信息暂时用不到时，换出到外存。（页面置换/段置换）

### **知识回顾**
- 传统存储管理方式的特征，缺点
    - 一次性：作业必须一次性全部装入内存后才能开始运行
    - 驻留性：一旦作业被装入内存，就会一直驻留在内存中，直到作业运行结束
- 局部性原理
    - 时间局部性：现在访问的指令、数据不久后可能被再次访问
    - 空间局部性：现在访问的内存单元周围的内存空间，可能在不久之后会被访问
    - 高速缓存技术：使用频繁的数据放到更高速的存储器中
- 虚拟内存的定义与特征
    - 程序不需全部装入即可运行，运行时根据需要动态调入数据，若内存不够，还需换出一些数据
    - 特征
        - 多次性：无需再作业运行时一次性全部装入内存，而是允许被分成多次调入内存
        - 对换性：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出
        - 虚拟性：从逻辑上扩充了内存的容量，使用户看到的内存容量远大于实际的容量 
- 如何实现虚拟内存技术
    - 程序执行时，访问的信息不在内存时，从外存调入；（请求调页）
    - 内存信息暂时用不到时，换出到外存。（页面置换/段置换）
    - 实现
        - 请求分页存储管理
        - 请求分段存储管理
        - 请求段页式存储管理

## 3.2.2 请求分页管理方式
### **知识总览**
- 页表机制
- 缺页中断机构
- 地址变换机构

### **页表机制**
- 基本内存分页存储管理的页表：
    （页号） | 内存块号
- 请求分页存储管理的页表：
    （页号） | 内存块号 | 状态位 | 访问字段 | 修改位 | 外存地址
    - 状态位：是否已调入内存
    - 访问字段：最近被访问过几次，或记录上次被访问的时间
    - 修改位： 页面被调入内存后是否被修改过
    - 外存地址：页面在外存中的存放位置

### **缺页中断机构**
- 思想：
    - 请求分页系统中，每当要**访问的页面不在内存**时，便产生一个**缺页中断**，然后由操作系统的缺页中断处理程序处理中断。
    - 此时**缺页进程阻塞**，放入阻塞队列，调页完成后再将其唤醒，放回就绪队列

    - 如果内存中有空闲块，则**分配一个空闲块**，将所缺页面装入该块，并修改页表中相关的页表项。
    - 如果内存中没有空闲块，则由**页面置换算法**选择一个页面**淘汰**，如果该页面在内存期间**被修改过**，则要将其**写回外存**，未修改的不用写回外存。
- 中断的分类：
    - 内中断（内部异常，信号来自CPU内部）
        - 陷阱，陷入（trap）    
            有意为之的异常，如系统调用
        - 故障（fault）     
            由错误条件引起的，可能被故障处理程序修复，如缺页中断
        - 终止（abort） 
            不可恢复的致命错误造成的结果，终止处理程序不再将控制返回到引发终止的应用程序，如整数除以0；
    - 外中断（信号来自CPU外部）
        - I/O中断请求
        - 人工干预

### **地址变换机构**

### **知识回顾**
- 页表机制
    - 状态位：是否已调入内存
    - 访问字段：最近被访问过几次，或记录上次被访问的时间
    - 修改位： 页面被调入内存后是否被修改过，修改过的页面才需要在置换时候被写回外存
    - 外存地址：页面在外存中的存放位置   
- 缺页中断机构
    - 找到页表项后，检查页面是否已在内存，若没在内存，产生一个**缺页中断**。
    - 缺页中断处理中，需要将目标页面调入内存，有必要时还要换出界面
    - 缺页中断属于内中断，属于内中断中的故障，即可能被系统修复的异常
    - 一条指令在执行过程中可能产生多次缺页中断
- 地址变换机构
    - 找到页表项时需要检查页面是否在内存中
    - 若页面不在内存中，需要请求调页
    - 若内存空间不够，还需换出页面
    - 页面调入内存后，需要修改相应页表项


## 3.2.3 页面置换算法
> 页面的换入换出需要磁盘的I/O，会有较大开销，因此一个较好的页面置换算法应该追求更少的缺页率。
### **知识总览**
- 最佳置换算法（OPT）
- 先进先出置换算法（FIFO）
- 最近最久未使用置换算法（LRU）
- 时钟置换算法（CLOCK）
- 改进型的时钟置换算法

### **最佳置换算法（OPT）**
> 每次选择淘汰的页面将是以后永不使用，或者在最长时间内不被访问的页面，这样可以保证最低的缺页率

- 缺点：无法实现。 因为需要预测接下来访问的是哪个页面。
### **先进先出置换算法（FIFO）**
> 每次选择淘汰的页面，是最早进入内存的页面
- 实现方法：    
    把调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时选择队头页面即可。 队列的最大长度取决于系统为内存分配了多少个内存块
- 缺点：
    - 为进程分配的物理块数增大时，缺页次数不减反增 （belady异常）
    - 与实际运行规律不适应，先进入页面也有可能最经常被访问，算法性能差。
### **最近最久未使用置换算法（LRU）**
> 每次淘汰的页面时最近最久未使用的页面
- 实现方法：    
每个页面对应的页表项中，用访问字段记录该页面**自上次被访问以来所经历的时间t**。 当需要淘汰一个页面时选择现有页面中t值最大的，即最近最久未使用的页面。

- 缺点：    
    实现需要专门的硬件支持，虽然算法性能好，但是实现困难，开销大

### **时钟置换算法（CLOCK）**
> 一种性能和开销较为均衡的算法，或最近未用算法（NRU）

### **改进型的时钟置换算法**

### **知识回顾**

## 3.2.4 页面分配策略
### **知识总览**
### **知识回顾**