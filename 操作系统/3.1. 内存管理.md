# 3.1. 内存管理

## 3.1.1 内存基础知识
### **知识总览**
- 什么是内存，有何作用
    - 存储单元
    - 内存地址
- 进程运行基本原理
    - 指令的工作原理
    - 逻辑地址 vs 物理地址
    - 从写程序到程序运行：编辑——编译——链接——装入
    - 三种链接方式
    - 三种装入方式

### **什么是内存**
> 内存是用于存放数据的硬件。程序执行前需要先放到内存中才能被CPU处理

- 存储单元： 内存中有一个一个的“小房间”，每个小房间就是一个存储单元
- 内存地址： 内存地址从0开始，每个地址对应一个存储单元

### **进程运行原理——指令**
> 我们写的代码要翻译成CPU能识别的指令，这些指令会告诉CPU应该去内存的哪个地方读取数据

### **物理地址VS逻辑地址**
- 物理地址： 绝对地址
- 逻辑地址： 相对地址

### **写程序到程序运行**
- **编译**  
    由编译程序把用户源代码(.c文件)编译成若干个目标模块（编译：高级语言翻译为机器语言）  
- **链接**  
    由链接程序将编译后形成的一组目标模块(.o文件)，以及所需库函数链接在一起，形成一个完整的装入模块(.exe文件)
- **装入**  
    由装入程序将装入模块装入内存运行。  
    装入模块中的指令地址指的是“相对地址”，即：相对于开始地址而言的地址，又称“逻辑地址”。（如：指令1：往地址为80的存储单元中写入1）

### **链接的三种方式**
- 静态链接  
    在程序运行之前，先将各目标模块以及他们所需的库函数连接成一个完整的可执行文件（装入模块），之后不再拆开。
- 装入时动态链接：  
    将各目标模块装入内存时，边装入边链接
- 运行时动态链接
    在程序执行中需要改目标模块时，才对他进行链接。优点是便于修改和更新，便于实现对目标模块的共享。

### **装入的三种方式**
- 绝对装入  
    > 在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码，装入程序将按照装入模块中的地址，将程序和数据装入内存。
    ```c++
    // 如果知道装入模块要从地址为100的地方开始放
    指令1：往地址为80的存储单元中写入1
    编译链接后得到
    指令1：往地址为180的存储单元中写入1
    ```
    此方法灵活性很低，只适用于单道程序环境

- 静态重定位
    > 又称 可重定位装入。编译、链接后的装入模块的地址都是从零开始的，指令中使用的地址、数据存放的地址，都是相对于起始地址开始的逻辑地址。可根据内存的当前情况，将装入模块装入到内存的适当位置。装入时对地址进行“重定位”，将逻辑地址变换为物理地址。

    - 一个作业装入内存时，必须分配其要求的全部内储存空间，如果没有足够的内存，就不能装入该作业。
    - 作业一旦进入内存后，在运行期间就不能再移动，也不能再申请内存空间。
    - 与绝对装入区别：装入模块中静态重定位储存的依然是逻辑地址，而绝对装入中装入模块储存的是物理地址。

- 动态重定位
    > 又称 动态运行时装入。编译、链接后的装入模块的地址都是从零开始的，装入程序把装入模块装入到内存后，并不会立即把逻辑地址转换为物理地址，而是把地址转换推迟到程序真正要执行时才进行。因此装入内存后所有的地址依然是逻辑地址。 这种方式需要一个重定位寄存器的支持。
    - 允许程序在内存中发生移动

### **知识回顾**
- 什么是内存，有何作用
    - 存储单元与内存地址
    - 内存地址：按字节编址和按字编址
- 进程运行基本原理
    - 指令的工作原理：操作码+若干参数
    - 逻辑地址 vs 物理地址：相对VS绝对
    - 从写程序到程序运行
        - 编辑源代码文件
        - 编译：源代码生成目标模块
        - 链接：由目标模块生成装入模块，连接后形成完整的逻辑地址
        - 装入：装入模块装入内存，装入后形成物理地址
    - 三种链接方式
        - 静态链接：装入前连接成一个完整装入模块
        - 装入时动态链接：运行前边装入边链接
        - 运行时动态链接：运行时需要目标模块才装入并链接
    - 三种装入方式
        - 绝对装入： 编译时产生绝对地址
        - 可重定位装入： 装入时将逻辑地址转换为物理地址
        - 动态运行时装入： 运行时将逻辑地址转换为物理地址，需设置重定位寄存器

## 3.1.2 内存管理的概念
### **知识总览**
- 内存空间的分配与回收
- 内存空间的扩充
- 地址转换
- 内存保护

### **内存空间的分配与回收**
见之后章节
### **内存空间的扩充**
见之后章节
### **地址转换**
见3.1.1
### **内存保护**
1. 方法一：CPU中设置上限寄存器，下限寄存器，存放进程的上、下限地址。进程的指令要访问某个地址时，CPU检查是否越界
2. 方法二：采用重定位寄存器和界地址寄存器进行越界检查，重定位寄存器存放的是进程的起始物理地址，界地址寄存器存放的是进程的最大逻辑地址。

### **知识回顾**
- 内存空间的分配与回收
- 内存空间的扩充
- 地址转换
- 内存保护
    - 保证各个进程在自己的内存空间内访问，不会越界访问
    - 两种方法
        - 上、下限寄存器
        - 重定位寄存器，界地址寄存器

## 3.1.3 内存空间的扩充：覆盖与交换
### **知识总览**
- 内存空间的扩充
    - 覆盖技术
    - 交换技术
    - 虚拟存储技术

### **覆盖技术**
- 解决“程序大小超过物理内存总和”的问题  
- 思想：
    1. 将程序分为多个段（多个模块）
    2. 常用的段常驻内存，不常用的段在需要时调入内存；
    3. 内存中分为一个 固定区 和若干个 覆盖区：
        - 需要常驻内存的段放在“固定区”，调入后不再调出
        - 不常用的段放在“覆盖区”，需要用时调入内存，用不到时调出内存
- 缺点：
    - 必须由程序员声明覆盖结构，操作系统完成自动覆盖。
    - 对用户不透明，增加了用户编程负担。
    - 现在已经退出了历史舞台

### **交换技术**
> 内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已经具备运行条件的进程换入内存。
- 在外存(磁盘)的什么位置保存被换出的进程
    - 文件区（离散分配方式）
        - 用于存放文件
        - 追求存储空间的利用率
    - 对换区（连续分配方式）
        - 空间只占磁盘空间小部分
        - 换出的进程数据就存放对换区
        - 对换区空间的管理主要追求换入换出速度，对换区的I/O速度比文件区的更快
- 什么时候应该交换
    - 许多进程运行且内存吃紧时进行，系统负荷降低就暂停
- 应该换出哪些进程
    - 优先换出阻塞进程
    - 换出优先级低的进程

PCB会常驻内存

### **知识回顾**
- 覆盖技术
    - 一个固定区
        - 存放最活跃的数据段
        - 固定区的程序段在运行过程中不会调入调出
    - 若干覆盖区
        - 不可能同时被访问程序段可共享一个覆盖区
        - 覆盖区中的程序段在运行过程中会根据需要被调入调出
    - 必须由程序员声明覆盖结构，操作系统完成自动覆盖
    - 缺点：对用户不透明，增加用户编程负担
- 交换技术
    - 内存紧张时，换出某些内存以腾出内存空间，再换入某些进程
    - 磁盘分为文件去和对换区，换出的进程放在对换区
- 覆盖与交换的区别
    - 覆盖是在同一个程序或者内存中的
    - 交换是在不同进程（作业）之中的

## 3.1.4 连续分配管理方式
### **知识总览**
- 单一连续分配
- 固定分区分配
- 动态分区分配

### **单一连续分配**
> 内存被分为系统区（位于内存的低地址部分，用于存放操作系统相关数据）和用户区（存放用户进程相关数据）。内存中只能有一道用户程序，独占整个用户区空间
- 优点： 
    - 实现简单；
    - 无外部碎片；
    - 可以采用覆盖技术扩充内存；
    - 不一定需要采取内存保护
- 缺点： 
    - 只适用于单用户、单任务的操作系统；
    - 有内部碎片（分配给某进程的内存区域中，如果有些部分没有用上，就是内部碎片）；
    - 存储器利用率极低。
    - 内部碎片与外部碎片区别：
        - 内部碎片就是已经被分配出去（能明确指出属于哪个进程）却不能被利用的内存空间；
        - 外部碎片指的是还没有被分配出去（不属于任何进程），但由于太小了无法分配给申请内存空间的新进程的内存空闲区域。
### **固定分区分配**
> 整个用户空间划分为若干个固定大小的分区，在每个分区中只装入一道作业。

- 分区大小相等
    - 缺乏灵活性，很适合用于用一台计算机控制多个相同对象的场合
- 分区大小不等
    - 增加灵活性，可以满足不同大小的进程需求
- 分区说明表的数据结构：实现各个分区的分配与回收
    - 每个表项对应分区的大小、起始地址、状态
- 优点：
    - 实现简单，无外部碎片
- 缺点：
    - 用户程序太大，所有分区都不能满足需求，不得不采用覆盖技术
    - 会有内部碎片

### **动态分区分配**
> 不会预先划分内存分区，根据进程的大小动态地建立分区。
- 用何种数据结构
    - 空闲分区表    
        每个空闲分区对应一个表项。表项中包括分区号、分区大小、分区起始地址等信息
    - 空闲分区链    
        每个分区地起始部分和末尾部分分别设置前向指针和后向指针。起始部分处还可记录分区大小等信息。

- 多空闲分区如何分配
    - 动态分区分配算法 见3.1.5
- 如何进行分配与回收
    - 空闲分区表
        - 如何分配
            - 一个内存分区分配完还有剩余：表中修改分区大小和起始地址
            - 一个内存分区刚好分配完：分区对应的表项删除
        - 如何回收
            - 回收区的后面有一个相邻的空闲分区：回收后合并
            - 回收区的前面有一个相邻的空闲分区：回收后合并
            - 回收区的前，后面都有一个相邻的空闲分区：回收后合并
            - 回收区的前，后面都没有相邻的空闲分区：新增一个表项

### **知识回顾**
- 单一连续分配
    - 只支持单道程序，内存分为系统区和用户区，用户程序存放在用户区
    - 无外部碎片，有内部碎片
- 固定分区分配
    - 支持多道程序，内存用户空间分为若干个固定大小的分区，每个分区只能装一道作业。
    - 无外部碎片， 有内部碎片
    - 两种方式：
        - 分区大小相等
        - 分区大小不等
- 动态分区分配
    - 支持多道程序。进程装入程序时，根据内存的大小动态地建立分区
    - 无内部碎片，有外部碎片
    - 外部碎片可通过紧凑技术解决
    - 回收内存分区时可能遇到四种情况

## 3.1.5 动态分区分配算法
> 如果很多个空闲分区都能满足需求时，应该选择哪个分区进行分配
### **知识总览**
- 首次适应算法(First Fit)
    - 算法思想： 每次都从低地址开始找，找到第一个能满足大小的空闲分区
    - 如何实现：空闲分区以**地址递增**的顺序排列。每次分配内存时顺序查找空闲分区链或者空闲分区表，找到大小能满足要求的第一个空闲分区。

- 最佳适应算法(Best Fit)
    - 算法思想：为了保证大进程到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区，优先使用更小的空闲区
    - 如何实现：空闲分区以**容量递增**的顺序排列。每次分配内存时顺序查找空闲分区链或者空闲分区表，找到大小能满足要求的第一个空闲分区。
    - 缺点：每次都选最小的分区进行分配，会留下越来越多的外部碎片。

- 最坏适应算法(Worst Fit)
    - 算法思想：为了解决最佳适应算法的问题（即留下太多难以利用的小碎片，可以在每次分配时候优先使用最大的连续空闲区）
    - 如何实现：空闲分区按**容量递减**次序连接，每次分配内存时顺序查找空闲分区链或者空闲分区表，找到大小能满足要求的第一个空闲分区。
    - 缺点：每次都选最大分区进行分配，会导致较大的连续空闲区被迅速用完。如果之后到达“大进程”则无内存分区可用。

- 临近适应算法(Next Fit)
    - 算法思想：首次适应算法每次都从链头开始查找。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，这也增加了查找的开销，如果每次都从上次结束的时候开始查找，就能解决这个问题。
    - 如何实现：空闲分区以**地址递增**的顺序排列。每次分配内存时**从上次查找结束的位置开始**查找空闲分区链或者空闲分区表，找到大小能满足要求的第一个空闲分区。
    - 缺点：高地址部分的大分区更可能被使用，划分为小分区。
### **知识回顾**
| 算法   | 算法思想               | 分区排列顺序 | 优点                                         | 缺点                                                             |
| -------- | -------------------------- | ------------ | ---------------------------------------------- | ------------------------------------------------------------------ |
| 首次适应 | 从头到尾找合适的分区 | 地址递增 | 综合看性能好，算法开销小           |                                                                    |
| 最佳适应 | 从小到大找合适的分区 | 容量递增 | 会有更多的大分区被保留下来，更能满足大进程需求 | 产生很多的，无法利用的碎片，算法开销大，回收分区后需要重新排序 |
| 最坏适应 | 从大到小找合适的分区 | 容量递减 | 可以减小难以利用的小碎片           | 大分区容易被用完，不利于大进程，算法开销大，回收分区后需要重新排序 |
| 临近适应 | 从上次结束位置找合适的分区 | 地址递增 | 不用每次都从低地址的小分区开始检索，算法开销小 | 高地址的大分区容易被用完                               |

## 3.1.6 基本分页存储管理的基本概念
### **知识总览**
非连续分配管理方式
- 基本分页存储管理
- 基本分段存储管理
- 段页式存储管理

### **基本概念**
- **内存空间**分为一个个大小相等的分区
    - 每个分区就是一个**页框**（也叫页帧，内存块，物理块）。
    - 每个页框都有一个编号，即“页框号”（也叫页帧号，内存块号，物理块号）
- **用户进程**也可分为与页框大小相等的一个个区域
    - 每个区域就是一个**页**（也叫页面）
    - 每个页面也有一个编号，从0开始

### **地址转换**
> 进程的每个分页在内存中都是离散存储，因此需要各页框在内存中的起始地址以及目标页框相对于起始位置的偏移量
1. 算出逻辑地址对应的页号
2. 算出逻辑地址在页面内的“偏移量”
3. 要知道该页号对应页面在内存中的起始地址
4. 物理地址=页面始址+偏移量

- 为了方便计算页号，页内偏移量，页面大小一般设为2的整数幂。  
假设32个二进制位表示逻辑地址，页面大小为2^12=4096B=4KB
    - 前20位就是页号
    - 后12位就是页内偏移量

### **页表**
> 上述章节第三步：要知道该页号对应页面在内存中的起始地址，操作系统要为每个进程建立一张页表
1. 一个进程对应一张页表
2. 进程的每一页对应一个页表项
3. 每个页表项由页号和块号组成
4. 页表记录进程页面和实际存放的内存块之间的对应关系
5. 每个页表项的长度是相同的，页号是“隐含”的。why？（可通过直接寻址找到页号对应的块号）
    - 例子： 某系统物理内存大小4GB，页面大小4KB，则每个页表应该至少为多少字节？  
    4GB=2^32B, 4KB=2^12B  
    因此4GB的内存总共会被分为2^20个内存块， 内存块号范围应该是0~2^20-1,因此至少要20个二进制位才能表示这么多的内存块号，因此至少要3个字节。  
    各页表项会按顺序连续地存放在内存中，如果该页表在内存中存放的起始地址为X，则M号页对应的页表项一定存放在X+3*M，因此页号可以是隐含的。  
    只需要知道页表的存放起始地址和页表项长度，即可找到各个页号对应的页表项存放的位置。  
    一个页表项占3B，如果进程由n个页面组成，则该进程的页表总共会占3*n字节。

### **知识回顾**
> 基本分页存储管理的基本概念
- 基本思想：把进程分页，各个页面可离散的放到各个内存块中
- 重要概念：
    - 页框，页帧，内存块，物理块 vs 页，页面
    - 页框号，页帧号，内存块号，物理块号 vs 页号，页面号
- 如何实现地址转换：
    1. 算出逻辑地址对应的页号
    2. 算出逻辑地址在页面内的“偏移量”
    3. 要知道该页号对应页面在内存中的起始地址
    4. 物理地址=页面始址+偏移量
- 页号、页内偏移量的计算：
    - 十进制算法：页号=逻辑地址/页面大小；页内偏移量=逻辑地址%页面大小
    - 二进制算法：若32位系统，页面大小为2^k,【页号P(前32-k位)，页内偏移量W(后k位)】
- 页表：
    - 页表记录进程页面和实际存放的的内存块之间的对应关系
    - 一个进程对应一张页表，进程的每一页对应一个页表项，每个页表项由页号和块号组成
    - 每个页表项的长度是相同的，页号是隐含的

## 3.1.7 基本分页存储管理：基本地址变换机构
> 通常会在系统中设置一个页表寄存器（PTR），存放页表再内存中的起始地址F和页表长度M。进程未执行时，**页表的始址**和**页表长度**放在**进程控制块（PCB）**中，进程被调度时，操作系统内核会把它们放到**页表寄存器**中

### **计算**
- 页表寄存器：页表始址F，页表长度M
- 逻辑地址A：页号P，页内偏移量W  
先通过F+P*单个块号字节数 找到页号P对应的内存块号b，然后用[b,W]获得物理地址
### **知识回顾**
- 页表寄存器的作用：
    - 存放页表起始位置
    - 存放页表长度
- 地址变换过程
    1. 根据逻辑地址算出页号，页内偏移量
    2. 页号的合法性检查（与页表长度对比）
    3. 若页号合法， 再根据页表起始位置，页号找到对应页表项
    4. 根据页表项中记录的内存块号、页内偏移量，得到最终的物理地址
    5. 访问物理内存对应的内存单元
- 其他小细节
    - 页内偏移量与页面大小之间的关系（要能用其中一个条件推出另一个条件）
    - 页式管理中地址是一维的
    - 实际应用中，通常使一个页框恰好能放入整数个页表项
    - 为了方便找到页表项，页表一般是放在连续的内存块中的 

## 3.1.8 基本分页存储管理：具有快表的地址变换机构
### **知识总览**
- 局部性原理
- 什么是快表（TLB）
- 引入快表后，地址的变换过程

### **局部性原理**
- 时间局部性  
    - 如果执行了程序中的某条指令，那么不久后这条指令有可能再次执行；
    - 如果某个数据被访问过，不久之后该数据可能再次被访问
- 空间局部性  
    一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。（因为很多数据在内存中都是连续存放的）

由于局部性原理，可能连续很多次查到的都是同一个页表项，可以利用这个特性减少访问页表的次数。

### **什么是快表（TLB）**
> 又称“联想寄存器”。 是一种访问速度比内存快很多的**高速缓冲存储器**，用来存放当前访问的若干页表项，以加速地址变换的过程。于此对应，内存中的页表常称为“慢表”

### **知识回顾**
- 基本地址变换机构
    - 地址变换过程
        1. 算页号，页内偏移量
        2. 检查页号合法性
        3. 查页表，找到页面存放的内存块号
        4. 根据内存块号和页内偏移量得到物理地址
        5. 访问目标内存单元
    - 访问一个逻辑地址的访存次数
        两次访存
- 具有快表的地址变换机构
    - 地址变换过程
        1. 算页号，页内偏移量
        2. 检查页号合法性
        3. 查快表。若命中，即可知道页面存放的内存块号，可直接进行5，若未命中则进行4
        4. 查页表，找到页面存放的内存块号，并且将页表项复制到快表中
        5. 根据内存块号与页内偏移量得到物理地址
        6. 访问目标内存单元
    - 访问一个逻辑地址的访存次数
        - 快表命中
        - 只需一次访存;快表未命中，需要两次访存

## 3.1.9 基本分页存储管理：两级页表
### **知识总览**
- 单级页表存在什么问题，如何解决
- 两级页表的原理、逻辑地址结构
- 如何实现地址变换
- 两级页表需要注意的几个细节

### **单级页表问题**
- 问题一：页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框
- 问题二：没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面 （虚拟存储技术，可以在页表项中增加一个标志位，用于表示该页面是否已经调入内存）

### **两级页表原理**
解决上述问题一。
- 可将长长的页表进行分组，使每个内存块刚好可以放入一个分组
- 为离散分配的页表再建立一张页表，称为页目录表，或称外层页表，或称顶层页表
### **地址变换**
例子：一个32位系统，页大小为4Kb（2^12）,则页内地址占12位
| 31 ... 22 | 21 ... 12 | 11 ... 0   |
| --------- | --------- | ---------- |
| 一级页号 | 二级页号 | 页内偏移量 |
将逻辑地址(00000000000,00000000001,111111111111)

1. 按照地址结构将逻辑地址拆分成三部分
2. 从PCB中读出页目录表始址，再根据一级页号查页目录表，找到下一级页表在内存中的存放位置
3. 根据二级页号查表，找到最终想访问的内存号块
4. 结合页内偏移量得到物理地址

### **两级页表需要注意的几个细节**
- 若采用多级页表，各级页表的大小不能超过一个页面
    - 例子：某系统按字节编址，采用40位逻辑地址，页面大小为4KB，页表项为4B，假设采用纯页式存储，则要采用（）级页表，页内偏移量为（）位？ 
    页内偏移量=页面大小位数；12位   
    则一共需要40-12=28位页号   
    页表长度<=页面大小/页表项大小=1K=2^10
    所以一共需要3级页表
- 两级页表访存分析
    - 第一次: 访问内存中的页目录表
    - 第二次: 访问内存中的二级页表
    - 第三次: 访问目标内存单元

### **知识回顾**
- 单级页表存在问题
    - 问题一：页表必须连续存放，页表很大时，需要占用很多个连续空间
    - 问题二：一段时间内可能只需要访问某几个特定的页面，没有必要让整个页表常驻内存 
- 两级页表
    - 将长长的页表再分页
    - 逻辑地址结构（一级页号，二级页号，页内偏置量）
    - 页目录表/外层页表/顶级页表
- 如何实现地址变换
    1. 按照地址结构将逻辑地址拆分成三部分
    2. 从PCB中读出页目录表始址，再根据一级页号查页目录表，找到下一级页表在内存中的存放位置
    3. 根据二级页号查表，找到最终想访问的内存号块
    4. 结合页内偏移量得到物理地址
- 几个细节
    - 若采用多级页表，各级页表的大小不能超过一个页面
    - 多级页表的访存次数——N级页表访问一个逻辑地址需要N+1次访存

## 3.1.10 基本分段存储管理方式
> 与分页存储管理方式最大区别：离散分配时所分配地址空间的基本单位不同
### **知识总览**
- 什么是分段
- 什么是段表
- 如何实现地址变换
- 分段、分页管理的对比

### **分段、段表**
> 进程的地址空间，按照程序自身的逻辑关系划分为若干个段，每个段都有一个段名，每段从零开始编址
- 内存分配规则：以段为单位进行分配，每个段在内存中占据连续空间，但各段之间可以不相邻
- 逻辑地址结构：段号（段名）+段内地址（段内偏移量）
- 段表：
    1. 每个段代表一个段表项，其中记录了该段在内存中的起始位置（“基址”）和段的长度
    2. 各个段表项的长度是相同的。因此段号可以是隐含的，不占存储空间。若段表存放的起始位置是M，则K号段对应的段表项存放的地址为M+K*6

### **如何进行地址变换**
段表寄存器：段表始址F，段表长度M
逻辑地址：段号S，段内地址W
段表项: （每段）段长C，基址B
1. 根据逻辑地址算出段号，段内地址
2. 判断段号是否越界。若S>=M,则产生越界中断，否则继续执行
3. 查询段表，找到对应的段表项，段表项存放的地址为F+S*段表项长度
4. 检查段内地址是否超过段长，若W>=C,则产生越界中断，否则继续执行
5. 计算得到物理地址
6. 访问目标内存单元

### **分段、分页区别**
- 页是信息的物理单位，对用户不可见；段是信息的逻辑单位，分段对用户是可见的
- 大小：
    - 页的大小固定且由系统决定。
    - 段的长度不固定，决定于用户编写的程序。
- 用户进程地址空间：
    - 分页的**用户进程**地址空间是**一维**的，
    - 分段的**用户进程**地址空间是**二维**的，既要给出段名，也要给出段内地址
- 信息共享和保护：分段比分页更容易实现信息的共享和保护
- 访问一个逻辑地址：
    - 分页： 两次（单级页表）
    - 分段： 两次

### **知识回顾**
- 分段
    - 进程的地址空间，按照程序自身的逻辑关系划分为若干个段，每段从零开始编址
    - 每个段在内存中占据连续空间，但各段之间可以不相邻
    - 逻辑地址结构：段号（段名）+段内地址（段内偏移量）
- 段表
    - 记录逻辑段到实际存储地址的映射关系
    - 每个段对应一个段表项。各段表项长度相同，由段号、段长、基址组成
- 地址变换
    1. 根据逻辑地址算出段号，段内地址
    2. 判断段号是否越界。若S>=M,则产生越界中断，否则继续执行
    3. 查询段表，找到对应的段表项，段表项存放的地址为F+S*段表项长度
    4. 检查段内地址是否超过段长，若W>=C,则产生越界中断，否则继续执行
    5. 计算得到物理地址
    6. 访问目标内存单元
- 分段VS分页
    - 分页对用户不可见，分段对用户可见
    - 分页的地址空间是一维的，分段是二维的（段名+段内地址）
    - 分段比分页更容易实现信息的共享和保护
    - 分页（单级页表）、分段访问一个逻辑地址都需要两次访存，分段存储中也可以引入快表机制。
## 3.1.11 段页式管理方式
### **知识总览**
- 分页分段管理方式中最大的优缺点
- 分段+分页的结合-段页式管理方式
- 段表，页表
- 如何实现地址变换

### **分页分段优缺点分析**
- 分页管理
    - 优点
        - 内存空间利用率高，不会产生外部碎片，只有少量的页内碎片
    - 缺点
        - 不方便按照逻辑模块实现信息的共享和保护（不同页共享一个页框，无法统一设定权限）
- 分段管理
    - 优点
        - 很方便按照逻辑模块实现信息的共享和保护
    - 缺点
        - 如果段长过大，为其分配很大的连续空间会很不方便
        - 段式管理会产生外部碎片。

### **分段+分页的结合-段页式管理方式** 
>将进程按逻辑块分段，再将各段分页（如每个页面4KB），再将内存空间分为大小相同的内存块/页框/页帧/物理块

- 逻辑地址结构      
    | 31 ... 16 | 15 ... 12 | 11 ... 0   |
    | --------- | --------- | ---------- |
    | 段号 | 页号 | 页内偏移量 |
    - 段号的位数决定了每个进程最多可以分多少段
    - 页号位数决定了每个段最大有多少页
    - 页内偏移量决定了页面大小，内存块大小是多少
### **段表、页表**
- 每个段对应一个段表项，**每个段表项由段号、页表长度、页表存放块号（页表起始地址）**（不同于段式管理中的段表结构）组成，每个段表项长度相等，段号隐含。
- 一个进程对应一个段表，一个段会对应一个页表，因此一个段表会对应多个页表，即一个进程会对应多个页表

### **知识回顾**

- 分段+分页
    - 将地址空间按照程序自身的逻辑关系划分为若干个段，再将各段分为大小相等的页面
    - 将内存空间分为与页面大小相等的一个个内存块，系统以块为单位为进程分配内存
    - 逻辑地址结构:(段号，页号，页内偏移量)
- 段表，页表
    - 每个段对应一个段表项。各段表项长度相同，由段号（隐含）、页表长度、页表存放地址组成
    - 每个页对应一个页表项。各页表项长度相同，由页号（隐含）、页面存放的内存块号组成
- 地址变换
    1. 由逻辑地址得到段号、页号、页内偏移量
    2. 段号与段表寄存器中的段长度比较，检查是否越界
    3. 由段表始址、段号找到对应段表项
    4. 依据段表中记录的页表长度，检查页号是否越界
    5. 由段表中的页表地址，页号得到查询页表，找到相应页表项
    6. 由页面存放的内存块号，页内偏移量得到的最终的物理地址
    7. 访问目标单元
- 访问一个逻辑地址所需访存次数
    - 第一次查段表，第二次查页表，第三次访问目标单元
    - 可引入快表机制，以段号和页号为关键字查询快表，可直接找到最终的目标页面存放位置。引入快表后仅需一次访存