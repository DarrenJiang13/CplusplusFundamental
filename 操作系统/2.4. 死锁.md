# 2.4. 死锁

## 2.4.1 死锁的概念
### **知识总览**
- 什么是死锁
- 进程死锁，饥饿，死循环的区别
- 死锁产生的必要条件
- 什么时候会产生死锁
- 死锁的处理策略

### **什么是死锁**
> 在并发环境下，各进程因竞争资源而造成的一种互相等待对方手里资源，导致各进程都阻塞，无法向前推进的现象，就是“死锁”。

### **进程死锁，饥饿，死循环的区别**
- 死锁：各进程因竞争资源而造成的一种互相等待对方手里资源，导致各进程都阻塞，无法向前推进的现象
- 饥饿：由于长期得不到想要的资源，某进程无法向前推进的现象
- 死循环：某进程执行过程中一直跳不出某个循环的现象，有时是BUG导致，有时是故意设计

|        | 共同点            | 区别                                                                             |
| ------ | -------------------- | ---------------------------------------------------------------------------------- |
| 死锁 | 进程无法顺利向前推进 | 至少有两个两个以上的进程同时发生死锁                             |
| 饥饿 | 进程无法顺利向前推进 | 可能只有一个进程发生饥饿                                               |
| 死循环 | 进程无法顺利向前推进 | 可能只有一个进程死循环。死循环是被管理者的问题，死锁和饥饿是管理者(操作系统)的问题 |

### **死锁产生的必要条件**
- 互斥条件  
    只有对必须互斥使用的资源的争抢才会导致死锁
- 不剥夺条件  
    进程所获得的资源未使用完之前，不能由其他进程强行夺走，只能主动释放
- 请求和保持条件  
    进程已经保持了至少一个名额，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放
- 循环等待条件  
    存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求

### **什么时候会产生死锁**
- 系统资源竞争  
    对不可剥夺资源的竞争
- 进程推进顺序非法
    请求和释放资源的顺序不当，如并发执行的进程P1，P2分别申请并占有了资源R1,R2，之后进程P1又申请资源R2，P2又申请资源R1，两者申请的资源都被对方占有而阻塞，从而发生死锁。
- 信号量使用不当
    互斥的P操作在实现同步的P操作之前， 有可能导致死锁。

### **死锁的处理策略**
- 预防死锁：破坏四个必要条件中的一个或几个
- 避免死锁：避免系统进入不安全状态
- 死锁的检测和解除： 允许死锁发生，系统负责检测出死锁并解除

### **知识回顾**
- 什么是死锁    
    各进程互相等待对方手里的资源，导致资源阻塞，无法向前推进
- 进程死锁，饥饿，死循环的区别  
    - 死锁：至少是两个进程一起死锁，死锁进程处于阻塞态
    - 饥饿：可以只有一个进程饥饿，饥饿进程可能阻塞也可能就绪
    - 死循环： 可能只有一个进程发生死循环，死循环的进程可上处理机
    - 思索和饥饿是操作系统要解决的问题，死循环是应用程序员要解决的
- 死锁产生的必要条件
    - 互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁
    - 不剥夺条件  
        进程保持的资源只能主动释放，不可强行剥夺
    - 请求和保持条件  
        保持着某些资源不放的同时，请求别的资源
    - 循环等待条件  
        存在一种进程资源的循环等待链。循环等待未必死锁，死锁一定循环等待
- 什么时候会产生死锁：
    对不可剥夺资源的不合理的分配
- 死锁的处理策略
    - 不允许死锁发生
        - 静态策略：预防死锁
        - 动态策略：避免死锁
    - 允许死锁发生
        - 死锁的检测与解除

## 2.4.2 预防死锁
### **知识总览**
- 破坏互斥条件
- 破坏不剥夺条件
- 破坏请求和保持条件
- 破坏循环条件

### **破坏互斥条件**
>互斥条件 只有对必须互斥使用的资源争抢才会导致死锁  
- 破坏： 把只能互斥使用的资源改造为允许共享使用
- 缺点： 并不是所有的资源都可以改造成可共享使用的资源，很多时候无法破坏互斥条件
### **破坏不剥夺条件**
>不剥夺条件 进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放

- 破坏：
    1. 当某个进程请求新的资源得不到满足时，必须立即释放保存的所有资源，待以后重新申请
    2. 当某个进程需要的资源被其他进程所占有的时候，可以由操作系统需协助，将想要的资源强行剥夺

- 缺点
    1. 实现起来较为复杂
    2. 释放已获得的资源可能造成前一阶段工作的失效
    3. 反复地申请和释放资源会增加系统开销，降低系统吞吐量
    4. 若采用方案一，可能造成饥饿（如果暂时得不到某个资源，之前获得的都要放弃）

### **破坏请求和保持条件**
> 请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。

- 破坏  
    采用静态分配方法，即进程在运行前一次就申请完它所需要的全部资源，在它的资源未满足前，不让它投入运行。

- 缺点  
    有些资源运行时间很短，因此如果进程的整个运行期间都一直保持着所有资源，就会造成严重的资源浪费，资源利用率极低。
    
### **破坏循环条件**
> 循环等待条件：存在一种进程资源的循环等待链，链中的每一个进程已经获得的资源都同时被下一个资源所请求

- 破坏  
    顺序资源分配法。首先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源。

- 缺点  
    - 不方便增加新的设备，可能需要重新分配所有的编号；
    - 进程实际使用资源的顺序可能与编号递增顺序不一致，会导致资源浪费
    - 必须按规定次序申请资源，用户编程麻烦

### **知识回顾**
- 破坏互斥条件
    - 将临界资源改为可共享使用的资源
    - 缺点：可行性不高，很多时候无法破坏
- 破坏不剥夺条件
    - 方案一：申请的资源得不到满足时，释放拥有的所有资源
    - 方案二：申请的资源被其他进程占用时候，由操作系统协助剥夺
    - 缺点：实现复杂；剥夺资源可能导致部分工作失效；反复申请和释放导致系统开销大；可能导致饥饿
- 破坏请求和保持条件
    - 运行前分配好所有需要的资源，之后一直保持
    - 缺点: 资源利用率低，可能导致饥饿
- 破坏循环等待条件
    - 给资源编号，必须按编号从小到大的顺序申请资源
    - 缺点：不方便增加新设备；会导致资源浪费；用户编程麻烦

## 2.4.3 避免死锁
### **知识总览**
- 什么是安全序列
- 什么是系统的不安全状态，和死锁有啥联系
- 如何避免系统进入不安全状态

### **什么是安全序列、不安全序列**
> 安全序列，系统如果按照这种序列分配资源，则每个进程都能顺利完成。

- 安全状态。只要能找出一个安全序列，系统就是安全状态。
- 不安全状态。 系统找不出任何一个安全序列，系统就进入了不安全状态。
- 系统处于安全状态，就**一定**不会发生死锁。如果系统在不安全状态，**可能**发生死锁

- 可以在资源分配之前预先判断这次分配是否会导致系统进入不安全状态，以此决定是否答应资源分配请求。——银行家算法

### **银行家算法**
1. 检查此次申请是否超过了之前声明的最大需求数
2. 检查此时系统剩余的可用资源是否还能满足这次请求
3. 试探着分配，更改各数据结构
4. 用安全性算法检查此次分配是否会导致系统进入不安全状态


## 2.4.4 检测与解除
### **知识总览**
- 死锁的检测
- 死锁的解除
### **死锁检测**
- 用某种数据结构来保存资源的请求和分配信息
    - 两种结点
        - 进程结点：对应一个进程
        - 资源结点：对应一类资源，一类资源可能有多个
    - 两种边:
        - 进程结点->资源结点：表示进程想申请几个资源
        - 资源结点->进程结点：表示已经为进程分配了几个资源
- 提供一种算法，利用上述信息来检测系统是否已经进入死锁状态
    1. 在资源分配图中，找出既不阻塞，又不是孤点的进程Pi，消去他所有的请求边和分配边，使之称为孤立的结点
    2. 进程Pi释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，原来的阻塞进程可变为非阻塞进程，若能消去途中所有的边，则称该图是可完全简化的。
- 如果某时刻系统的资源分配图是不可完全简化的，那么此时系统死锁。

### **死锁解除**
> 一旦检测出死锁的发生，就应该立即接触死锁

- 资源剥夺法。挂起某些死锁进程，并抢占他的资源，将这些资源分配给其他的死锁进程，但应防止饥饿；
- 撤销进程法。 强制撤销部分，甚至全部死锁进程，并剥夺这些进程的资源。
- 进程回退法。选择一个或多个死锁进程，回退到足以避免死锁的地步。

### **知识回顾**
- 如何检测
    - 数据结构：资源分配图
        - 两种结点
            - 进程结点
            - 资源结点
        - 两种边:
            - 进程结点->资源结点(请求边)
            - 资源结点->进程结点(分配边)
    - 死锁检测算法
        - 一次消除与不阻塞进程相连的边，直到无边可消
        - 注：所谓不阻塞进程是指其申请的资源数还足够的进程
        - 死锁定理：若资源分配图是不可完全简化的，说明发生了死锁
- 如何解除
    - 资源剥夺法
    - 撤销进程法
    - 进程回退法