# 4.2 内联函数inline
> c/c++程序在执行函数时，所用的时间主要分为**函数调用**和**执行函数体代码**。如果函数体代码比较多，需要较长的执行时间，那么函数调用机制占用的时间可以忽略；如果函数只有一两条语句，那么大部分的时间都会花费在函数调用机制上，这种时间开销就就不容忽视。  
为了解决一些<u>**频繁调用</u>的<u>小函数</u>大量消耗栈空间/栈内存**的问题，C++ 提供一种提高效率的方法，即在编译时将函数调用处用函数体替换，类似于C语言中的宏展开。特别的引入了 inline 修饰符，表示为**内联函数**。

- 使用示例：
    ```c++
    // c版本代码
    #include <stdio.h>
    //函数定义为inline即:内联函数
    inline char* dbtest(int a) {
        return (i % 2 > 0) ? "odd" : "even";
    } 
    
    int main()
    {
    int i = 0;
    for (i=1; i < 100; i++) {
        printf("i:%d    奇偶性:%s /n", i, dbtest(i));    
    }
    }
    ```
    上面的例子就是标准的内联函数的用法，使用 inline 修饰带来的好处我们表面看不出来，其实，在内部的工作就是在每个 for 循环的内部任何调用 dbtest(i) 的地方都换成了 (i%2>0)?"odd":"even"，这样就**避免了频繁调用函数对栈内存重复开辟所带来的消耗**。

## inline 函数的定义
- 要在函数定义处添加 inline 关键字，在函数声明处添加 inline 关键字虽然没有错，但这种做法是无效的，编译器会忽略函数声明处的 inline 关键字。即“**inline是用于实现的关键字**”。
- 由于内联函数比较短小，我们通常的做法是**在函数声明时直接完成函数定义**。不推荐把内联函数的声明的定义分开。
- 最好将内联函数定义放在头文件中。

## 类中的成员函数与inline
- **定义在类中**的成员函数默认都是**内联**的;
- **定义在类外**的函数要**加上 inline**，否则就认为不是内联的。
    ```c++
    class A
    {
        public:void Foo(int x, int y) {  } // 自动地成为内联函数
    }

    //将成员函数的定义体放在类声明之中虽然能带来书写上的方便，但不是一种良好的编程风格，上例应该改成：

    // 头文件
    class A
    {
        public:void Foo(int x, int y);
    }
    // 定义文件
    inline void A::Foo(int x, int y){}
    ```

## inline仅是一个对编译器的建议
inline 函数仅仅是一个对编译器的建议，所以最后能否真正内联，看编译器的意思，它如果认为函数不复杂，能在调用点展开，就会真正内联，并不是说声明了内联就会内联，声明内联只是一个建议而已。

## 使用限制
inline 只适合函数体内代码简单的函数使用，不能包含复杂的结构控制语句例如 while、switch，并且内联函数本身不能是直接递归函数（即，自己内部还调用自己的函数）。

## 慎用 inline
内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。  

以下情况不宜使用内联：   
- 如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。 
- 如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。  
类的构造函数和析构函数容易让人误解成使用内联更有效。要当心构造函数和析构函数可能会隐藏一些行为，如"偷偷地"执行了基类或成员对象的构造函数和析构函数。

## 内联函数与宏
- 使用宏代码的最大缺点是容易出错，预处理器在拷贝宏代码时常产生意想不到的边际效应，如：
    ```c
    #define MAX(a,b)  (a)>(b)?(a):(b)
    ```
    语句  
    ```c
    result=MAX(i,j)+2;
    ```
    将被处理器扩展为
    ```
    result=(a)>(b)?(a):(b)+2;
    ```

    因为"+"的优先级比运算符"?:"高，故上述语句不等价于
    ```
    result=((a)>(b)?(a):(b))+2;
    ```
    故常需要定义成
    ```c
    #define MAX(a,b)  ((a)>(b)?(a):(b))
    ```
- 宏代码的另一缺点是不可调试，内联函数可调试。
- c++中宏代码另一缺点：无法操作类的私有数据成员。
- 内联函数另一优点：函数被内联后，编译器可以通过上下文相关的优化技术对结果代码执行更加深入的优化。
